
const effects = ['Volume', 'Panoramic', 'Sustain', 'Reverb', 'Chorus', 'ADSR', 'Echo', 'Distortion', 'Metronome'];
const panoramicMajorPoints = [[-1, 0], [0, 0], [1, 0], [0, -1.5], [0, 1.5]];

if (!localStorage.getItem('currentPage')) localStorage.setItem('currentPage', '0');
let currentPage = parseInt(localStorage.getItem('currentPage')); //Page on which the user is
const radius = 110 * effects.length / (2 * Math.PI); //Radius of the circle for the carousel
/*
    The radius is calculated strangely but 100 is the with of the screen in vw (actually I put 110 because otherwise we can see the others window a little bit too much at my taste...) and it works for normal screens but when you start to squeeze them and your sreen is like a square you can see the others effects screens appear at the bottom
    So it's not perfect and I tried my best but it's not that bad... I can't update it when the window is resized because I'd have to move every screens as the value of the radius would be uptated. But it's kinda cool to see the others screens exceeding...
*/
const total = effects.length; 

const transitionTime = .8; //Transition time of the scrolling between 2 windows
const initialTransition = `transform ${transitionTime}s ease-in-out`; //Dynamic transition if I want to change later

const svgNS = 'http://www.w3.org/2000/svg'; //Element to precise a SVG element


const colors = [[80, 200, 120], [230, 80, 80]]; //Colors used for ON or OFF by some effects

const numberOfCircles = 10; //Number of circles generated by the sustain animation
const numberOfCirclesForMetronome = 6; //Number of circles generated by the metronome animation

let panoramicDragging = false;
const MAX_PATH_POINTS = 1000; //Value for the path recording on the panoramic window


const MAX_WAV_FILE_SIZE = 5_000_000; //The maximum size for a .wav to be saved in IndexedDB is 5 Mo


// ________________________________________________________________________________________________


const stage2 = document.querySelector('#stage2');

const btnFX = document.createElement('btn');
btnFX.id = 'btnFX';
for (let i = 1; i < 4; i++) {
    const sliderBar = document.createElement('div');
    sliderBar.classList.add('sliderBar');

    const knob = document.createElement('div');
    knob.id = `knob${i}`;

    sliderBar.appendChild(knob);
    btnFX.appendChild(sliderBar);
}

const effectShortcutBtn1 = CreateHTMLElement('btn', stage2, 'effectShortcutBtn1', true);
const effectShortcutBtn2 = CreateHTMLElement('btn', stage2, 'effectShortcutBtn2', true);
stage2.appendChild(btnFX);
const effectShortcutBtn3 = CreateHTMLElement('btn', stage2, 'effectShortcutBtn3', true);
const effectShortcutBtn4 = CreateHTMLElement('btn', stage2, 'effectShortcutBtn4', true);

effectShortcutBtn1.textContent = 'Metronome';
effectShortcutBtn2.textContent = 'Echo';
effectShortcutBtn3.textContent = 'Reverb';
effectShortcutBtn4.textContent = 'Panoramic';



const effectsContainer = document.querySelector('#effectsContainer');
ChangeDisplay([effectsContainer], 0);

const btnNavLeft = document.createElement('btn');
const carouselWrapper = document.createElement('div');
const btnNavRight = document.createElement('btn');
const btnQuitEffects = document.createElement('btn');

btnNavLeft.id = 'btnNavLeft';
carouselWrapper.id = 'carouselWrapper';
btnNavRight.id = 'btnNavRight';
btnQuitEffects.id = 'btnQuitEffects';

{
    const leftArrow = document.createElement('i');
    leftArrow.classList.add('fas');
    leftArrow.classList.add('fa-arrow-left');
    btnNavLeft.appendChild(leftArrow);

    const rightArrow = document.createElement('i');
    rightArrow.classList.add('fas');
    rightArrow.classList.add('fa-arrow-right');
    btnNavRight.appendChild(rightArrow);

    const closeIcon = document.createElement('i');
    closeIcon.classList.add('fas');
    closeIcon.classList.add('fa-close');
    btnQuitEffects.appendChild(closeIcon);
}


function CreateElementForCarousel(type, parent, id, title, name, index) {
    const element = CreateHTMLElement(type, parent, id, true);

    const divTitle = document.createElement('div');
    divTitle.classList.add(title);
    divTitle.textContent = name;

    element.appendChild(divTitle);

    const deg = (360 / total) * index;
    element.style.transform = `
        rotateZ(${deg}deg)
        translateY(-${radius}vw)
    `;
}

const carousel = document.createElement('div');
carousel.id = 'carousel';
for (let i = 0; i < effects.length; i++) {
    CreateElementForCarousel('div', carousel, `${effects[i].toLowerCase()}Screen`, 'effectTitle', effects[i], i);
}
carousel.style.transform = `translateY(${radius}vw)`;
carousel.style.transition = initialTransition;
carouselWrapper.appendChild(carousel);


effectsContainer.appendChild(btnNavLeft);
effectsContainer.appendChild(carouselWrapper);
effectsContainer.appendChild(btnNavRight);
effectsContainer.appendChild(btnQuitEffects);



btnFX.addEventListener('click', () => { OpenEffectsWindow(currentPage); });
effectShortcutBtn1.addEventListener('click', () => { currentPage = 8; OpenEffectsWindow(currentPage); });
effectShortcutBtn2.addEventListener('click', () => { currentPage = 6; OpenEffectsWindow(currentPage); });
effectShortcutBtn3.addEventListener('click', () => { currentPage = 3; OpenEffectsWindow(currentPage); });
effectShortcutBtn4.addEventListener('click', () => { currentPage = 1; OpenEffectsWindow(currentPage); });
btnQuitEffects.addEventListener('click', CloseEffectsWindow);
window.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'flex' && event.code == 'Escape') CloseEffectsWindow();
});
btnNavLeft.addEventListener('click', ScrollPreviousWindow);
btnNavRight.addEventListener('click', ScrollNextWindow);

const knob1 = document.querySelector('#knob1');
const knob2 = document.querySelector('#knob2');
const knob3 = document.querySelector('#knob3');
function OpenEffectsWindow(page) {
    TurnCarousel(page);

    knob1.style.transform = 'translateX(2vw) translateY(-50%)';
    knob2.style.transform = 'translateX(.5vw) translateY(-50%)';
    knob3.style.transform = 'translateX(2vw) translateY(-50%)';
    setTimeout(() => {
        effectsContainer.style.display = 'flex';

        UpdateEventListeners(null, page); //I don't want to remove event listeners that do not exist
        UpdatePosition();
    }, 500);
}
function CloseEffectsWindow() {
    Animate(btnQuitEffects, 'rotate-fast', 300);
    setTimeout(() => {
        effectsContainer.style.display = 'none';

        knob1.style.transform = 'translateX(.5vw) translateY(-50%)';
        knob2.style.transform = 'translateX(2vw) translateY(-50%)';
        knob3.style.transform = 'translateX(.5vw) translateY(-50%)';
    }, 300);

    UpdateEventListeners(currentPage, null); //I want to remove event listeners but not create others
}

function ScrollPreviousWindow() {
    Rotate(-1);
    Animate(btnNavLeft, 'moveLeft', transitionTime * 1000);
}
function ScrollNextWindow() {
    Rotate(1);
    Animate(btnNavRight, 'moveRight', transitionTime * 1000);
}

let animationTimeout;
function Rotate(direction) {
    if (animationTimeout) return;
    const index = currentPage + direction;
    const angle = -index * (360 / total);

    //I'm doing that here because, otherwise, the loading happens too late. But I have let the others currentPage...
    const nextPage = (index + total) % total;
    UpdateEventListeners(currentPage, nextPage);

    currentPage = nextPage;
    UpdatePosition();
    localStorage.setItem('currentPage', currentPage.toString());

    carousel.style.transform = `translateY(${radius}vw) rotateZ(${angle}deg)`;
    animationTimeout = setTimeout(() => {
        clearTimeout(animationTimeout);
        animationTimeout = null;
    }, transitionTime * 1000);

    if (0 < index && index < total - 1) {
        currentPage = index;
    } else {
        TurnCarousel(index, true);
    }
}

function TurnCarousel(index, wait = false) { //Turn carousel without animation
    const waitTime = wait ? transitionTime * 1000 : 0;

    index = (index + total) % total;
    const angle = -index * (360 / total);

    if (animationTimeout) {
        clearTimeout(animationTimeout);
        animationTimeout = null;
    }
    animationTimeout = setTimeout(() => {
        requestAnimationFrame(() => {
            carousel.style.transition = 'none';
            carousel.style.transform = `translateY(${radius}vw) rotateZ(${angle}deg)`;

            requestAnimationFrame(() => {
                carousel.style.transition = initialTransition;
                currentPage = index;
                clearTimeout(animationTimeout);
                animationTimeout = null;
            });
        });
    }, waitTime);
}

document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none') return;

    const key = event.code;
    if (key == 'ArrowLeft') { Rotate(-1); }
    if (key == 'ArrowRight') { Rotate(1); }
});


// ________________________________________________________________________________________________


const volumeContent = document.createElement('div');
const volumeControl = document.createElement('div');
const volumeKnob = document.createElement('div');
volumeContent.id = 'volumeContent';
volumeControl.id = 'volumeControl';
volumeKnob.id = 'volumeKnob';

volumeControl.appendChild(volumeKnob);
volumeContent.appendChild(volumeControl);
document.querySelector('#volumeScreen').appendChild(volumeContent);

// It's in order to put the shadow BELOW the SVG wave...
const volumeControl2 = document.createElement('div');
volumeControl2.id = 'volumeControl2';
volumeContent.appendChild(volumeControl2);


const volumeSVG = document.createElementNS(svgNS, "svg");
volumeSVG.id = 'volumeSVG';
volumeSVG.setAttribute("viewBox", "0 0 200 200");
volumeSVG.setAttribute("width", "100%");
volumeSVG.setAttribute("height", "100%");
volumeContent.appendChild(volumeSVG);

const linePath = document.createElementNS(svgNS, "path");
linePath.setAttribute("id", "line");
linePath.setAttribute("stroke", "#0ff");
linePath.setAttribute("stroke-width", "2");
linePath.setAttribute("fill", "rgba(0,255,170,0.6)");
volumeSVG.appendChild(linePath);


function UpdateKnobFromVolume() {
    const angle = volumeValue / 200 * 300;
    const clamped = Math.max(0, Math.min(300, angle)); 
    const radians = (clamped - 90) * Math.PI / 180;

    const parentRadius = volumeContent.getBoundingClientRect().height * 0.9 / 2;

    const radius = parentRadius - (parentRadius * 0.73 - parentRadius * 0.65) / 2;
    const cx = parentRadius;
    const cy = parentRadius;

    const x = cx + radius * Math.cos(radians);
    const y = cy + radius * Math.sin(radians);

    volumeKnob.style.left = `${x}px`;
    volumeKnob.style.top = `${y}px`;

    UpdateVolumeValue();
    volumeText.textContent = volumeValue + '%';

    glowCenterBeam = 30 + angle;
    spreadBeam = angle < 150 ? Math.min(20, angle) : Math.min(20, 300 - angle);
}

function Wave(t, x) {
    if (!isPlaying) {
        return (
            Math.cos(t * 2 + x * 0.015) * 3 +
            Math.sin(t * 3.5 + x * 0.04) * 2 +
            Math.cos(t * 1.2 + x * 0.007 + Math.sin(x * 0.002 + t * 0.1)) * 1.5
        );
    } else {
        const base = Math.sin(t * 1.5 + x * 0.01) * 6;
        const ripple = Math.sin(t * 6 + x * 0.05) * 2;
        const flutter = Math.cos(t * 9 + x * 0.12) * 1.5;
        return base + ripple + flutter;
    }
}
function GeneratePath(cx, cy, radius, spreadDeg, centerDeg, xOffset) {
    const leftSide = [];
    const rightSide = [];

    const steps = Math.ceil(radius / 2);
    const spreadRad = spreadDeg * Math.PI / 180;
    const halfSpread = spreadRad / 2;
    const centerRad = (centerDeg + 90) * Math.PI / 180;

    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const r = radius * t;

        const offset = Wave(t, xOffset);

        const angleLeft = centerRad - halfSpread + offset * 0.05;
        const xLeft = cx + r * Math.cos(angleLeft);
        const yLeft = cy + r * Math.sin(angleLeft);
        leftSide.push([xLeft, yLeft]);

        const angleRight = centerRad + halfSpread - offset * 0.05;
        const xRight = cx + r * Math.cos(angleRight);
        const yRight = cy + r * Math.sin(angleRight);
        rightSide.unshift([xRight, yRight]);
    }

    const angleLeft = Math.atan2(leftSide[leftSide.length - 1][1] - cy, leftSide[leftSide.length - 1][0] - cx);
    const angleRight = Math.atan2(rightSide[0][1] - cy, rightSide[0][0] - cx);

    let delta = angleRight - angleLeft;
    if (delta < 0) delta += Math.PI * 2;

    const sweepFlag = delta > Math.PI ? 0 : 1;

    let d = `M ${cx},${cy}`;
    for (let [x, y] of leftSide) d += ` L ${x},${y}`;
    d += ` A ${radius} ${radius} 0 0 ${sweepFlag} ${rightSide[0][0]} ${rightSide[0][1]}`;
    for (let [x, y] of rightSide) d += ` L ${x},${y}`;
    d += " Z";

    return d;
}

let cxBeam, cyBeam, rBeam, spreadBeam, glowCenterBeam;
let lastResizeTimeForVolumeSVG;
let animationIdForVolumeSVG;
function CalculatePositions() {
    t = 0;

    function CalcPosForVolSVG() {
        CalculatePositionsForVolumeSVG();
        UpdateKnobFromVolume();

        if (performance.now() - lastResizeTimeForVolumeSVG < 1000) {
            animationIdForVolumeSVG = requestAnimationFrame(CalcPosForVolSVG);
        }
    }

    if (animationIdForVolumeSVG) {
        cancelAnimationFrame(animationIdForVolumeSVG);
        animationIdForVolumeSVG = null;
    }
    lastResizeTimeForVolumeSVG = performance.now();

    animationIdForVolumeSVG = requestAnimationFrame(CalcPosForVolSVG);

    cancelAnimationFrame(waveAnimationId);
    waveAnimationId = requestAnimationFrame(AnimateWaveForVolume);
}
function CalculatePositionsForVolumeSVG() {
    const VCR = volumeContent.getBoundingClientRect(); //short for Volume Content Rect

    const parentRadius = VCR.height * 0.9 / 2;
    const knobSize = parentRadius * 0.73 - parentRadius * 0.65;
    volumeKnob.style.width = `${knobSize}px`;
    volumeKnob.style.height = `${knobSize}px`;

    cxBeam = VCR.width / 2;
    cyBeam = VCR.height / 2;

    if (!isPlaying) rBeam = VCR.height * 0.9 / 2 - (parentRadius * 0.73 - parentRadius * 0.65) / 2;
    else rBeam = Math.hypot(VCR.width, VCR.height) / 2;

    volumeSVG.setAttribute("viewBox", `0 0 ${VCR.width} ${VCR.height}`);
}
let t = 0;
let waveAnimationId = null;
function AnimateWaveForVolume() {
    t += isPlaying ? .5 : 1;
    t = (t + 1) % 10000;

    const d = GeneratePath(cxBeam, cyBeam, rBeam, spreadBeam, glowCenterBeam, t);
    if (d.includes("NaN")) return;
    linePath.setAttribute("d", d);

    waveAnimationId = requestAnimationFrame(AnimateWaveForVolume);
}


let volumeDragging = false;
function VolumeOnMouseMove(e) {
    if (effectsContainer.style.display == 'none' || currentPage != 0 || !volumeDragging) return;

    const rect = volumeControl.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    const dx = e.clientX - cx;
    const dy = e.clientY - cy;

    const angleDeg = Math.atan2(dy, dx) * (180 / Math.PI);
    let adjusted = (angleDeg + 270) % 360;

    if (adjusted > 330 || adjusted < 30) adjusted = Math.max(30, Math.min(adjusted, 330));

    const relativeAngle = adjusted - 30;
    volumeValue = Math.round((relativeAngle / 300) * 200);

    UpdateKnobFromVolume();
}

function VolumeOnMouseDown() {
    if (effectsContainer.style.display != 'none' && currentPage == 0) {
        volumeDragging = true;
    }
}
function VolumeOnMouseUp() {
    if (!volumeDragging) return;
    volumeDragging = false;
    TestVolume();
}


const volumeText = document.createElement('div');
volumeText.id = 'volumeText';
volumeText.textContent = volumeValue + '%';
document.querySelector('#volumeScreen').appendChild(volumeText);

document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 0) return;

    const key = event.code;
    if (key == 'ArrowUp') {
        if (volumeValue < 200) volumeValue++;
        UpdateKnobFromVolume();
    }
    if (key == 'ArrowDown') {
        if (volumeValue > 0) volumeValue--;
        UpdateKnobFromVolume();
    }
});


// ________________________________________________________________________________________________


const sustainContent = document.createElement('div');
sustainContent.id = 'sustainContent';
document.querySelector('#sustainScreen').appendChild(sustainContent);


const sustainBtn = document.createElement('btn');
sustainBtn.id = 'sustainBtn';

const sustainPicture = document.createElement('img');
sustainPicture.src = "Pictures/pedal.png";

sustainBtn.appendChild(sustainPicture);
sustainContent.appendChild(sustainBtn);

const sustainSVG = document.createElementNS(svgNS, "svg");
sustainSVG.id = 'sustainSVG';
sustainSVG.setAttribute("viewBox", "0 0 200 200");
sustainSVG.setAttribute("width", "100%");
sustainSVG.setAttribute("height", "100%");
sustainContent.appendChild(sustainSVG);

for (let i = 0; i < numberOfCircles; i++) {
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', '100');
    circle.setAttribute('cy', '100');
    circle.setAttribute('r', '0');
    circle.setAttribute('stroke-width', '3');
    circle.setAttribute('fill', 'none');

    sustainSVG.appendChild(circle);
}


let animationStartTime = null;
function AnimateWaveForSustain() {
    if (animationStartTime != null && performance.now() - animationStartTime < 4000) return;

    let r = 0;
    const maxR = 300;
    const duration = 2000;
    animationStartTime = performance.now();

    function Step(now) {
        let progress = 0;
        for (let i = 0; i < numberOfCircles; i++) {
            const circle = sustainSVG.children[i];
            const elapsed = now - animationStartTime - i * 100;
            progress = Math.max(0, Math.min(elapsed / duration, 1));

            r = maxR * progress;
            circle.setAttribute('r', r);
            circle.style.strokeOpacity = 1 - progress;

            if (progress < .01) {
                if (!sustainMode) circle.setAttribute('stroke', 'rgba(0, 255, 0, 0.7)');
                else circle.setAttribute('stroke', 'rgba(255, 0, 0, 0.7)');
            }

            if (!i) {
                const start = sustainMode ? colors[0] : colors[1];
                const end = sustainMode ? colors[1] : colors[0];

                const red = start[0] + progress * (end[0] - start[0]);
                const green = start[1] + progress * (end[1] - start[1]);
                const blue = start[2] + progress * (end[2] - start[2]);

                document.querySelector('#sustainScreen').style.background = `rgba(${red}, ${green}, ${blue}, 1)`;
            }
        }

        if (progress < 1) {
            requestAnimationFrame(Step);
        } else {
            for (let i = 0; i < numberOfCircles; i++) {
                const circle = sustainSVG.children[i];
                circle.setAttribute('r', 0);
                circle.style.strokeOpacity = 0;
            }

            ToggleSustainMode();
        }
    }

    requestAnimationFrame(Step);
}

sustainBtn.addEventListener('click', AnimateWaveForSustain);

document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 2) return;

    const key = event.code;
    if (key == 'Enter' || key == 'Space') {
        AnimateWaveForSustain();
    }
});


// ________________________________________________________________________________________________


const globalGain = audioCtx.createGain();
const globalPanL = audioCtx.createGain();
const globalPanR = audioCtx.createGain();
const merger = audioCtx.createChannelMerger(2);

globalGain.connect(globalPanL);
globalGain.connect(globalPanR);

globalPanL.connect(merger, 0, 0);
globalPanR.connect(merger, 0, 1);

merger.connect(audioCtx.destination);

globalGain.gain.value = 1.5;

const panoramicContent = document.createElement('div');
panoramicContent.id = 'panoramicContent';
document.querySelector('#panoramicScreen').appendChild(panoramicContent);

const panoramicView = document.createElement('div');
panoramicView.id = 'panoramicView';
panoramicContent.appendChild(panoramicView);

const panoramicSettings = document.createElement('div');
panoramicSettings.id = 'panoramicSettings';
panoramicContent.appendChild(panoramicSettings);

const panoramicSVG = document.createElementNS(svgNS, "svg");
panoramicSVG.id = 'panoramicSVG';
panoramicSVG.setAttribute("viewBox", "-2 -2 4 4");
panoramicSVG.setAttribute("width", "100%");
panoramicSVG.setAttribute("height", "100%");
panoramicView.appendChild(panoramicSVG);

let panoramicCircle = document.createElementNS(svgNS, 'circle');
let movePath = document.createElementNS(svgNS, "path");
let knobX = document.createElementNS(svgNS, "path");
let knobY = document.createElementNS(svgNS, "path");
let panoramicKnob = document.createElementNS(svgNS, 'circle');
{
    const panoramicLine1 = document.createElementNS(svgNS, "path");
    panoramicLine1.setAttribute("id", "panoramicLine1");
    panoramicLine1.setAttribute("stroke", "rgba(0, 0, 0, 0.4)");
    panoramicLine1.setAttribute("stroke-width", ".01");
    panoramicLine1.setAttribute("d", 'M -2,0 L 2,0');
    panoramicSVG.appendChild(panoramicLine1);

    const panoramicLine2 = document.createElementNS(svgNS, "path");
    panoramicLine2.setAttribute("id", "panoramicLine2");
    panoramicLine2.setAttribute("stroke", "rgba(0, 0, 0, 0.4)");
    panoramicLine2.setAttribute("stroke-width", ".01");
    panoramicLine2.setAttribute("d", 'M 0,-2 L 0,2');
    panoramicSVG.appendChild(panoramicLine2);

    panoramicCircle.setAttribute("id", "panoramicCircle");
    panoramicCircle.setAttribute('cx', '0');
    panoramicCircle.setAttribute('cy', '0');
    panoramicCircle.setAttribute('r', '1.5');
    panoramicCircle.setAttribute('stroke-width', '.02');
    panoramicCircle.setAttribute('fill', 'none');
    panoramicCircle.setAttribute('stroke', 'rgba(100, 100, 100, 0.6)');
    panoramicSVG.appendChild(panoramicCircle);

    movePath.setAttribute("id", "movePath");
    movePath.setAttribute('stroke-width', '.02');
    movePath.setAttribute('fill', 'none');
    movePath.setAttribute('stroke', 'rgba(100, 100, 100, 0.6)');
    panoramicSVG.appendChild(movePath);

    knobX.setAttribute("id", "knobX");
    knobX.setAttribute("stroke", "rgba(0, 255, 0, 0.8)");
    knobX.setAttribute("stroke-width", ".02");
    knobX.setAttribute("d", 'M 0,0 L 0,0');
    panoramicSVG.appendChild(knobX);

    knobY.setAttribute("id", "knobY");
    knobY.setAttribute("stroke", "rgba(0, 255, 0, 0.8)");
    knobY.setAttribute("stroke-width", ".02");
    knobX.setAttribute("d", 'M 0,0 L 0,0');
    panoramicSVG.appendChild(knobY);

    const panoramicCircle1 = document.createElementNS(svgNS, 'circle');
    panoramicCircle1.setAttribute("id", "panoramicCircle1");
    panoramicCircle1.setAttribute('cx', '-1');
    panoramicCircle1.setAttribute('cy', '0');
    panoramicCircle1.setAttribute('r', '.03');
    panoramicCircle1.setAttribute('fill', 'rgba(255, 0, 0, 0.8)');
    panoramicSVG.appendChild(panoramicCircle1);

    const panoramicCircle2 = document.createElementNS(svgNS, 'circle');
    panoramicCircle2.setAttribute("id", "panoramicCircle2");
    panoramicCircle2.setAttribute('cx', '1');
    panoramicCircle2.setAttribute('cy', '0');
    panoramicCircle2.setAttribute('r', '.03');
    panoramicCircle2.setAttribute('fill', 'rgba(255, 0, 0, 0.8)');
    panoramicSVG.appendChild(panoramicCircle2);

    panoramicKnob.setAttribute("id", "panoramicKnob");
    panoramicKnob.setAttribute('cx', '0');
    panoramicKnob.setAttribute('cy', '0');
    panoramicKnob.setAttribute('r', '.05');
    panoramicKnob.setAttribute('fill', 'rgba(255, 255, 255, 1)');
    panoramicSVG.appendChild(panoramicKnob);
}
movePath.style.display = 'none';

function PanoramicOnMouseDown1() {
    if (effectsContainer.style.display != 'none' && currentPage == 1) {
        panoramicDragging = true;
    }
}
function PanoramicOnMouseDown2(e) {
    if (effectsContainer.style.display != 'none' && currentPage == 1) {
        panoramicKnob.style.cursor = 'grabbing';
        panoramicDragging = true;
        PanoramicOnMouseMove(e);
    }
}
function PanoramicOnMouseUp() {
    if (!panoramicDragging) return;
    panoramicKnob.style.cursor = 'grab';
    panoramicDragging = false;

    if (soundPreviewBtn.checked) {
        const audio = audioInstances['0:128']['C3'];
        audio.play();
    }

    if (recordBtnState == 1 && recordedPath.length > 0) {
        jumpList.push(recordedPath.length - 1);
    }
}


function PanoramicOnMouseMove(e) {
    if (effectsContainer.style.display == 'none' || currentPage != 1 || !panoramicDragging) return;

    const rect = panoramicView.getBoundingClientRect();

    if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top  || e.clientY > rect.bottom) {
        panoramicKnob.style.cursor = 'grab';
        panoramicDragging = false;
        return;
    }

    let x = ((e.clientX - rect.left) / rect.width) * 4 - 2;
    let y = ((e.clientY - rect.top) / rect.height) * 4 - 2;

    if (snapBtn.checked) {
        for (let [dx, dy] of panoramicMajorPoints) {
            const dst = Math.hypot(dx - x, dy - y);
            if (dst < .25) {
                x = dx;
                y = dy;
            }
        }
    }

    if (recordBtnState == 1) {
        if (recordedPath.length == 0) {
            startOfRecording = performance.now();
            recordedPath.push([x, y, 0]);

            movePath.setAttribute("d", `M ${x},${y}`);
        } else {
            const dstToFirstPoint = Math.hypot(recordedPath[0][0] - x, recordedPath[0][1] - y);
            if (recordedPath.length > 5 && dstToFirstPoint < .1) {
                x = recordedPath[0][0];
                y = recordedPath[0][1];
            }

            const lastPoint = recordedPath[recordedPath.length - 1];
            const dstToLastPoint = Math.hypot(lastPoint[0] - x, lastPoint[1] - y);
            if (dstToLastPoint > .03) {
                recordedPath.push([x, y, performance.now() - startOfRecording]);

                let d = movePath.getAttribute('d');
                if (loopModeBtn.checked) d = d.slice(0, -1);

                d += `L ${x},${y}`;
                if (loopModeBtn.checked) d += 'Z';

                movePath.setAttribute("d", d);

                if (recordedPath.length >= MAX_PATH_POINTS) recordBtn.click();
            }
        }
    }

    SetPanoramicValues(x, y);
}
function SetPanoramicValues(x, y) {
    panoramicKnob.setAttribute('cx', `${x}`);
    panoramicKnob.setAttribute('cy', `${y}`);

    knobX.setAttribute("d", `M 0,${y} L ${x},${y}`);
    knobY.setAttribute("d", `M ${x},0 L ${x},${y}`);

    SetGlobalPan(x, y);
}

function SetGlobalPan(x, y) {
    const distanceL = Math.max(Math.hypot(x + 1, y), 0.4);
    const distanceR = Math.max(Math.hypot(x - 1, y), 0.4);

    const areaL = Math.PI * distanceL * distanceL;
    const areaR = Math.PI * distanceR * distanceR;

    const volL = 1 / areaL;
    const volR = 1 / areaR;

    globalPanL.gain.value = volL;
    globalPanR.gain.value = volR;
}
SetGlobalPan(0, 0);


const panoramicTitle = document.querySelector('#panoramicScreen').firstChild;
document.querySelector('#panoramicScreen').removeChild(panoramicTitle);
panoramicSettings.appendChild(panoramicTitle);

const rotateBtn = CreateButtonsWithLabels('rotateBtn', panoramicSettings, 'Auto Rotate');
const moveSpeedBox = CreateHTMLElement('div', panoramicSettings, 'moveSpeedBox', true);
const onlyXBtn = CreateButtonsWithLabels('onlyXBtn', panoramicSettings, 'X Axis Only');
const onlyYBtn = CreateButtonsWithLabels('onlyYBtn', panoramicSettings, 'Y Axis Only');
const snapBtn = CreateButtonsWithLabels('snapBtn', panoramicSettings, 'Snap to Points');
const soundPreviewBtn = CreateButtonsWithLabels('soundPreviewBtn', panoramicSettings, 'Preview Sound');

AttachTooltip(document.querySelector('#panoramicSettings .effectTitle'), 'This effect sounds best when combined with echo or reverb', 300);
{
    let tooltipEl = null;
    let timeout = null;

    rotateBtnLabel.addEventListener('mouseenter', () => {
        timeout = setTimeout(() => {
            tooltipEl = document.createElement('div');
            tooltipEl.className = 'tooltip';
            if (recordBtnState == 0) tooltipEl.textContent = 'Rotate the panoramic along the circle';
            else tooltipEl.textContent = 'Move the panoramic along the recorded path';
            document.body.appendChild(tooltipEl);

            const rect = rotateBtnLabel.getBoundingClientRect();
            tooltipEl.style.left = `${rect.left + rect.width / 2}px`;
            tooltipEl.style.transform = 'translateX(-50%)';
            requestAnimationFrame(() => {
                tooltipEl.style.top = `${rect.top - tooltipEl.getBoundingClientRect().height - 12}px`;
                tooltipEl.style.opacity = 1;
            });
        }, 300);
    });

    rotateBtnLabel.addEventListener('mouseleave', () => {
        clearTimeout(timeout);
        if (tooltipEl) {
            tooltipEl.remove();
            tooltipEl = null;
        }
    });
}
AttachTooltip(document.querySelector('#onlyXBtnLabel'), 'Restrict movement to the X axis', 300);
AttachTooltip(document.querySelector('#onlyYBtnLabel'), 'Restrict movement to the Y axis', 300);
AttachTooltip(document.querySelector('#snapBtnLabel'), 'Snap the knob to main points\n(e.g. center, left or right ear)', 300);
AttachTooltip(document.querySelector('#soundPreviewBtnLabel'), 'Play a \'C4\' each time you release the knob', 300);

const moveSpeedSlider = CreateInput('moveSpeedSlider', -5, 5, 1, 'range', moveSpeedBox);

moveSpeedSlider.addEventListener('mouseup', () => {
    moveSpeedSlider.blur();
});
moveSpeedSlider.addEventListener('touchend', () => {
    moveSpeedSlider.blur();
});

moveSpeedSlider.step = '.1';
const moveSpeedText = CreateHTMLElement('div', moveSpeedBox, 'moveSpeedTxt', true);
moveSpeedText.innerText = 'Speed : 1';

rotateBtn.addEventListener('click', AnimatePanoramic);
moveSpeedSlider.addEventListener('input', () => {
    moveSpeedText.innerText = `Speed : ${Math.round(moveSpeedSlider.value * 10) / 10}`;
});
onlyXBtn.addEventListener('click', () => {
    if (onlyXBtn.checked && onlyYBtn.checked) {
        onlyYBtn.checked = false;
        ChangeColor(onlyYBtn);
    }
});
onlyYBtn.addEventListener('click', () => {
    if (onlyYBtn.checked && onlyXBtn.checked) {
        onlyXBtn.checked = false;
        ChangeColor(onlyXBtn);
    }
});
snapBtn.addEventListener('click', () => {
    if (!snapBtn.checked) return;
    let x = parseFloat(panoramicKnob.getAttribute('cx'));
    let y = parseFloat(panoramicKnob.getAttribute('cy'));
    
    for (let [dx, dy] of panoramicMajorPoints) {
        const dst = Math.hypot(dx - x, dy - y);
        if (dst < .25) {
            x = dx;
            y = dy;
        }
    }

    SetPanoramicValues(x, y);
});
soundPreviewBtn.addEventListener('click', () => {
    if (soundPreviewBtn.checked) {
        const audio = audioInstances['0:128']['C3'];
        audio.play();
    }
});

let panoramicAnimationId = null;
let playHead = 0;
function AnimatePanoramic() {
    if (recordBtnState == 1) recordBtn.click();

    if (!rotateBtn.checked) {
        if (panoramicAnimationId) {
            cancelAnimationFrame(panoramicAnimationId);
            panoramicAnimationId = null;
        }
        return;
    }

    if (!playModeBtn.checked) {
        const cx = parseFloat(panoramicKnob.getAttribute('cx'));
        const cy = parseFloat(panoramicKnob.getAttribute('cy'));

        let angleRad = Math.atan2(cy, cx);
        if (cx == 0 && cy == 0) angleRad = -Math.PI / 2;

        function AnimateRotation() {
            angleRad -= 180 / Math.PI / 20000 * moveSpeedSlider.value;
            angleRad = angleRad % (Math.PI * 2);

            const x = onlyYBtn.checked ? 0 : Math.cos(angleRad) * 1.5;
            const y = onlyXBtn.checked ? 0 : Math.sin(angleRad) * 1.5;

            SetPanoramicValues(x, y);

            panoramicAnimationId = requestAnimationFrame(AnimateRotation);
        }

        panoramicAnimationId = requestAnimationFrame(AnimateRotation);
    }
    else {
        if (recordedPath.length == 0) return;

        let pathStartTime = null;
        let lastTimestamp = null;
        let playingForward = true;
        const pathDuration = recordedPath[recordedPath.length - 1][2];

        function FollowPath(timestamp) {
            if (!pathStartTime) {
                pathStartTime = timestamp;
                lastTimestamp = timestamp;
            }

            const deltaTime = (timestamp - lastTimestamp);
            lastTimestamp = timestamp;

            const rawSpeed = moveSpeedSlider.value;
            const speed = Math.abs(rawSpeed) / 2;
            let direction = playingForward ? 1 : -1;
            direction *= rawSpeed >= 0 ? 1 : -1;

            playHead += deltaTime * speed * direction;

            direction = direction == 1 ? true : false;

            if (loopModeBtn.checked) {
                if (playHead > pathDuration) playHead = 0;
                if (playHead < 0) playHead = pathDuration;
            } else {
                if (direction && playHead > pathDuration) {
                    playHead = pathDuration;
                    playingForward = !playingForward;
                } else if (!direction && playHead < 0) {
                    playHead = 0;
                    playingForward = !playingForward;
                }
            }

            let i = 0;
            while (i < recordedPath.length - 1 && recordedPath[i + 1][2] < playHead) {
                i++;
            }

            const [x1, y1, t1] = recordedPath[i];
            const [x2, y2, t2] = recordedPath[i + 1];

            const alpha = (playHead - t1) / (t2 - t1);
            const x = onlyYBtn.checked ? 0 : x1 + (x2 - x1) * alpha;
            const y = onlyXBtn.checked ? 0 : y1 + (y2 - y1) * alpha;

            SetPanoramicValues(x, y);

            panoramicAnimationId = requestAnimationFrame(FollowPath);
        }

        panoramicAnimationId = requestAnimationFrame(FollowPath);
    }
}


let startOfRecording = performance.now();
let recordedPath = [];
let recordBtnState = 0;
const jumpList = [];
const recordBtn = CreateButtonsWithLabels('recordBtn', panoramicSettings, 'Record Path', 'checkbox', false);
const settingsBox = CreateHTMLElement('div', panoramicSettings, 'settingsBox', true);
const playModeBtn = CreateButtonsWithLabels('playModeBtn', settingsBox, 'Play Mode');
const loopModeBtn = CreateButtonsWithLabels('loopModeBtn', settingsBox, 'Loop Mode');
settingsBox.style.display = 'none';

const recordBtnLabel = document.querySelector('#recordBtnLabel');

{
    let tooltipEl = null;
    let timeout = null;

    recordBtnLabel.addEventListener('mouseenter', () => {
        timeout = setTimeout(() => {
            tooltipEl = document.createElement('div');
            tooltipEl.className = 'tooltip';
            if (recordBtnState == 0) tooltipEl.textContent = 'Start recording a custom panoramic path';
            else if (recordBtnState == 1) tooltipEl.textContent = 'Stop recording the path';
            else tooltipEl.textContent = 'Clear the recorded path';
            document.body.appendChild(tooltipEl);

            const rect = recordBtnLabel.getBoundingClientRect();
            tooltipEl.style.left = `${rect.left + rect.width / 2}px`;
            tooltipEl.style.transform = 'translateX(-50%)';
            requestAnimationFrame(() => {
                tooltipEl.style.top = `${rect.top - tooltipEl.getBoundingClientRect().height - 12}px`;
                tooltipEl.style.opacity = 1;
            });
        }, 300);
    });

    recordBtnLabel.addEventListener('mouseleave', () => {
        clearTimeout(timeout);
        if (tooltipEl) {
            tooltipEl.remove();
            tooltipEl = null;
        }
    });
}
AttachTooltip(document.querySelector('#playModeBtnLabel'), 'Switch between auto rotate and custom path', 300);
AttachTooltip(document.querySelector('#loopModeBtnLabel'), 'Toggle loop or ping-pong play mode', 300);

recordBtn.addEventListener('click', () => {
    recordBtnState = (recordBtnState + 1) % 3;

    if (recordBtnState == 1) {
        settingsBox.style.display = 'flex';
        if (!playModeBtn.checked) playModeBtn.click();

        if (rotateBtn.checked) rotateBtn.click();

        recordBtnLabel.textContent = 'Stop Recording';
    } else if (recordBtnState == 2) {
        let offset = 0;
        for (let idx of jumpList) {
            let index = idx + offset;

            if (index >= 0 && index < recordedPath.length - 1) {
                let newPoint = [recordedPath[index][0], recordedPath[index][1], Math.max(.001, recordedPath[index + 1][2] - .001)];
                recordedPath.splice(index + 1, 0, newPoint);
                offset++;
            }
        }

        recordBtnLabel.textContent = 'Remove Path';
    } else {
        settingsBox.style.display = 'none';

        if (rotateBtn.checked && playModeBtn.checked) rotateBtn.click();

        if (playModeBtn.checked) playModeBtn.click();

        recordedPath = [];
        movePath.removeAttribute("d");

        recordBtnLabel.textContent = 'Record Path';
    }
});
playModeBtn.addEventListener('click', () => {
    if (playModeBtn.checked) {
        rotateBtnLabel.textContent = 'Play Path';
        movePath.style.display = 'block';
        panoramicCircle.style.display = 'none';

        if (rotateBtn.checked) rotateBtn.click();
    } else {
        rotateBtnLabel.textContent = 'Auto Rotate';
        movePath.style.display = 'none';
        panoramicCircle.style.display = 'block';

        if (rotateBtn.checked) rotateBtn.click();

        playHead = 0;
    }
});
loopModeBtn.addEventListener('click', () => {
    if (loopModeBtn.checked) {
        let d = movePath.getAttribute('d') + 'Z';

        movePath.setAttribute("d", d);
    } else {
        let d = movePath.getAttribute('d').slice(0, -1);

        movePath.setAttribute("d", d);
    }
});


window.addEventListener('blur', () => {
    if (rotateBtn.checked) {
        SetPanoramicValues(0, 0);
    }

    if (eventMoveAnimationId != null) {
        panoramicPressedKeys = new Set();

        cancelAnimationFrame(eventMoveAnimationId);
        eventMoveAnimationId = null;
    }
});


let panoramicPressedKeys = new Set();
let eventMoveAnimationId = null;

document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 1) return;

    panoramicPressedKeys.add(event.code);

    if (eventMoveAnimationId === null) {
        eventMoveAnimationId = requestAnimationFrame(HandleEventMovement);
    }
});

document.addEventListener('keyup', (event) => {
    panoramicPressedKeys.delete(event.code);

    if (panoramicPressedKeys.size === 0) {
        cancelAnimationFrame(eventMoveAnimationId);
        eventMoveAnimationId = null;
    }
});

function HandleEventMovement() {
    let x = parseFloat(panoramicKnob.getAttribute('cx'));
    let y = parseFloat(panoramicKnob.getAttribute('cy'));

    if (panoramicPressedKeys.has('KeyW')) y -= 0.01;
    if (panoramicPressedKeys.has('KeyA')) x -= 0.01;
    if (panoramicPressedKeys.has('KeyS')) y += 0.01;
    if (panoramicPressedKeys.has('KeyD')) x += 0.01;

    SetPanoramicValues(x, y);

    eventMoveAnimationId = requestAnimationFrame(HandleEventMovement);
}


// _____________________________________________ Reverb ___________________________________________


const defaultReverbFreq = 0.5;
const defaultReverbMix = 1;
const defaultIsSf2UsedForReverb = 1;
if (!localStorage.getItem('reverb')) localStorage.setItem('reverb', `1;${defaultReverbFreq};${defaultReverbMix};${defaultIsSf2UsedForReverb}`);

{
    const values = localStorage.getItem('reverb').split(';');
    const str = 1 + ';' + values[1] + ';' + values[2] + ';' + values[3];
    localStorage.setItem('reverb', str.toString());
    //I made the enable button a variable that is saved throughout the reloads of the piano but actually it's better to disabled it by default. Because at the loading, it can be enabled but no Impulse Response Buffer will be input so no sound will be made and you will think the piano is just broken. So why not just withdrawing it from localStorage and made it a 'false' by default ? Because it's annoying, I'll have to rearrange a lot of code and it's easier like that...
}
let reverbFreq = parseFloat(localStorage.getItem('reverb').split(';')[1]); //Value of 0,5 by default, so the cut frequency is 6000Hz
let reverbMix = parseFloat(localStorage.getItem('reverb').split(';')[2]); //Value by default of 1, full wet
let impulseResponseBuffer = null; //Audio file to simulate the environment that will be added by a user input

const reverbDryGain = audioCtx.createGain();
const reverbWetGain = audioCtx.createGain();
const reverbConvolver = audioCtx.createConvolver();
const reverbFilter = audioCtx.createBiquadFilter();
const reverbOutput = audioCtx.createGain();
const reverbSendGain = audioCtx.createGain();

reverbConvolver.buffer = impulseResponseBuffer;
reverbFilter.type = "lowpass";
reverbFilter.frequency.value = 8000; //Default value but doesn't really matter anyway because it will be changed later so it's useless...

reverbDryGain.connect(reverbOutput);
reverbWetGain.connect(reverbConvolver).connect(reverbFilter).connect(reverbOutput);

const reverbInput = audioCtx.createGain();
reverbInput.connect(reverbDryGain);
reverbInput.connect(reverbSendGain).connect(reverbWetGain);

const reverbNode = {
    input: reverbInput,
    output: reverbOutput,
    SetMix(mix) {
        reverbDryGain.gain.value = 1 - mix;
        reverbWetGain.gain.value = mix;
    },
    SetHighFreq(val) {
        reverbFilter.frequency.value = 1000 + val * 9000;
    }
};

reverbNode.SetMix(localStorage.getItem('reverb').split(';')[0] === '0' ? reverbMix : 0);
reverbNode.SetHighFreq(reverbFreq);
reverbNode.output.connect(globalGain);

const reverbContent = CreateHTMLElement('div', document.querySelector('#reverbScreen'), 'reverbContent', true);

const reverbTop = CreateHTMLElement('div', reverbContent, 'reverbTop', true);
const reverbBottom = CreateHTMLElement('div', reverbContent, 'reverbBottom', true);

const reverbActivateBox = CreateHTMLElement('div', reverbTop, 'reverbActivateBox', true);
const reverbImportBox = CreateHTMLElement('div', reverbTop, 'reverbImportBox', true);

const reverbFreqBox = CreateHTMLElement('div', reverbBottom, 'reverbFreqBox', true);
const reverbMixBox = CreateHTMLElement('div', reverbBottom, 'reverbMixBox', true);

const reverbTitle = document.querySelector('#reverbScreen').firstChild;
document.querySelector('#reverbScreen').removeChild(reverbTitle);
reverbTop.appendChild(reverbTitle);

const reverbFreqValue = CreateHTMLElement('div', reverbFreqBox, 'reverbFreqValue', true);
const reverbFreqTrueValue = CreateHTMLElement('div', reverbFreqBox, 'reverbFreqTrueValue', true);
const reverbFreqTitle = CreateHTMLElement('div', reverbFreqBox, 'reverbFreqTitle', true);
reverbFreqTitle.textContent = 'Cut Frequency';

const reverbMixValue = CreateHTMLElement('div', reverbMixBox, 'reverbMixValue', true);
const reverbMixTitle = CreateHTMLElement('div', reverbMixBox, 'reverbMixTitle', true);
reverbMixTitle.textContent = 'Mix Dry/Wet';

function UpdateReverbTexts() {
    const value1 = Math.round(reverbFreq * 100) / 100;
    const length1 = value1.toString().length;
    reverbFreqValue.textContent = length1 == 3 ? value1 + '0' : length1 == 1 ? value1 + '.00' : value1;
    reverbFreqTrueValue.textContent = Math.round(1000 + value1 * 9000) + ' Hz';

    const value2 = Math.round(reverbMix * 100) / 100;
    const length2 = value2.toString().length;
    reverbMixValue.textContent = length2 == 3 ? value2 + '0' : length2 == 1 ? value2 + '.00' : value2;
}
UpdateReverbTexts();


function BuildArcPath(cx, cy, r, startAngle, endAngle, steps = 60) {
    const path = [];
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const angle = startAngle + (endAngle - startAngle) * t;
        const x = cx + r * Math.cos(angle);
        const y = cy - r * Math.sin(angle);
        path.push(`${i === 0 ? 'M' : 'L'} ${x} ${y}`);
    }
    return path.join(' ');
}
function DisplayReverbSlider(freq) {
    let id, reverbBox, value;
    if (freq) {
        id = 'reverbFreqSVG';
        reverbBox = reverbFreqBox;
        value = reverbFreq;
    }
    else {
        id = 'reverbMixSVG'
        reverbBox = reverbMixBox;
        value = reverbMix;
    }

    const width = reverbBox.clientWidth;
    const height = reverbBox.clientHeight;

    const reverbSVG = document.createElementNS(svgNS, "svg");
    reverbSVG.id = id;
    reverbSVG.setAttribute("viewBox", `0 0 ${width} ${height}`);
    reverbSVG.setAttribute("width", "100%");
    reverbSVG.setAttribute("height", "100%");
    reverbBox.appendChild(reverbSVG);
    reverbSVG.style.display = 'block';

    const minSize = Math.min(width, height * 2);
    const radius = minSize * 0.4;
    const centerX = width / 2;
    const centerY = height / 2 + radius / 2;

    const startX = centerX - radius;
    const endX = centerX + radius;
    const arcPath = `
        M ${startX} ${centerY}
        A ${radius} ${radius} 0 0 1 ${endX} ${centerY}
    `;

    const arc = document.createElementNS(svgNS, "path");
    arc.setAttribute('d', arcPath);
    arc.setAttribute('stroke', '#888');
    arc.setAttribute('stroke-width', '4');
    arc.setAttribute('fill', 'none');

    reverbSVG.appendChild(arc);

    DisplayReverbSlider2(reverbSVG, value, reverbBox);

    const children = Array.from(reverbBox.children);
    for (const child of children) {
        if (child.namespaceURI === svgNS) {
            reverbBox.removeChild(child);
        }
    }
    reverbBox.appendChild(reverbSVG);
}
function DisplayReverbSlider2(reverbSVG, value, reverbBox) {
    const width = reverbBox.clientWidth;
    const height = reverbBox.clientHeight;

    const minSize = Math.min(width, height * 2);
    const radius = minSize * 0.4;
    const centerX = width / 2;
    const centerY = height / 2 + radius / 2;

    const angle = Math.PI * value;
    const handleX = centerX - radius * Math.cos(angle);
    const handleY = centerY - radius * Math.sin(angle);

    const activeArc = document.createElementNS(svgNS, "path");
    const startAngle = Math.PI;
    const endAngle = Math.PI * (1 - value);
    const activePath = BuildArcPath(centerX, centerY, radius, startAngle, endAngle);
    activeArc.setAttribute('d', activePath);
    activeArc.setAttribute('stroke', '#f80');
    activeArc.setAttribute('stroke-width', '6');
    activeArc.setAttribute('fill', 'none');

    const handle = document.createElementNS(svgNS, 'circle');
    handle.setAttribute('cx', handleX);
    handle.setAttribute('cy', handleY);
    handle.setAttribute('r', '8');
    handle.setAttribute('fill', '#f80');
    handle.setAttribute('stroke', '#fff');
    handle.setAttribute('stroke-width', '2');

    if (reverbDragging.state && (reverbSVG.id == 'reverbFreqSVG') == reverbDragging.freq) handle.style.cursor = 'grabbing';

    let isReverbMouseleaveAttached = false;
    handle.addEventListener('mousedown', () => {
        if (effectsContainer.style.display !== 'none' && currentPage === 3) {
            reverbDragging = {
                state: true,
                freq: reverbSVG.id === 'reverbFreqSVG'
            };

            reverbSVG.style.cursor = 'grabbing';
            handle.style.cursor = 'grabbing';

            if (!isReverbMouseleaveAttached) {
                isReverbMouseleaveAttached = true;

                reverbContent.addEventListener('mouseleave', () => {
                    if (!reverbDragging.state) return;
                    if (reverbDragging.freq !== (reverbSVG.id === 'reverbFreqSVG')) return;

                    reverbDragging.state = false;
                    reverbSVG.style.cursor = 'auto';
                    handle.style.cursor = 'grab';
                });
            }
        }
    });

    reverbSVG.appendChild(activeArc);
    reverbSVG.appendChild(handle);
}


let reverbDragging = { state: false, freq: false };
function ReverbOnMouseMove(e) {
    if (effectsContainer.style.display == 'none' || currentPage != 3 || !reverbDragging.state) return;

    let reverbSVG, value, reverbBox, reverbValue;
    if (reverbDragging.freq) {
        reverbSVG = document.querySelector('#reverbFreqSVG');
        value = reverbFreq;
        reverbBox = reverbFreqBox;
        reverbValue = reverbFreqValue;
    } else {
        reverbSVG = document.querySelector('#reverbMixSVG');
        value = reverbMix;
        reverbBox = reverbMixBox;
        reverbValue = reverbMixValue;
    }

    const width = reverbBox.clientWidth;
    const height = reverbBox.clientHeight;
    const minSize = Math.min(width, height * 2);
    const radius = minSize * 0.4;

    const rect = reverbBox.getBoundingClientRect();
    const cx = rect.left + width / 2;
    const cy = rect.top + height / 2 + radius / 2;

    const dx = e.clientX - cx;
    const dy = e.clientY - cy;

    const angleRad = Math.atan2(-dy, -dx); // [-, ]
    let clampedRad = Math.max(0, Math.min(Math.PI, angleRad)); //clamp between 0 and 
    if (angleRad < -Math.PI / 2) clampedRad = Math.PI;

    value = Math.round((clampedRad / Math.PI) * 100) / 100;

    const length = value.toString().length;
    reverbValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

    for (let _ = 0; _ < 2;  _++) reverbSVG.removeChild(reverbSVG.lastChild);
    DisplayReverbSlider2(reverbSVG, value, reverbBox);

    if (reverbDragging.freq) {
        reverbFreq = value;
        reverbNode.SetHighFreq(reverbFreq);

        reverbFreqTrueValue.textContent = Math.round(1000 + value * 9000) + ' Hz';

        const values = localStorage.getItem('reverb').split(';');
        const str = values[0] + ';' + reverbFreq + ';' + values[2] + ';' + values[3];
        localStorage.setItem('reverb', str.toString());
    } else {
        reverbMix = value;
        reverbNode.SetMix(reverbMix);

        const values = localStorage.getItem('reverb').split(';');
        const str = values[0] + ';' + values[1] + ';' + reverbMix + ';' + values[3];
        localStorage.setItem('reverb', str.toString());
    }
}

function ReverbOnMouseUp() {
    if (!reverbDragging.state) return;
    reverbDragging.state = false;

    document.querySelector('#reverbFreqSVG').style.cursor = 'auto';
    document.querySelector('#reverbMixSVG').style.cursor = 'auto';

    document.querySelector('#reverbFreqSVG circle').style.cursor = 'grab';
    document.querySelector('#reverbMixSVG circle').style.cursor = 'grab';
}


const reverbImportBtn = CreateHTMLElement('btn', reverbImportBox, 'reverbImportBtn', true);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-import');
    reverbImportBtn.appendChild(i);
}
const reverbImportInput = CreateHTMLElement('input', reverbImportBox, 'reverbImportInput', true);
reverbImportInput.type = "file";
reverbImportInput.accept = ".wav";

const reverbNameBox = CreateHTMLElement('div', reverbImportBox, 'reverbNameBox', true);
const reverbImportName = CreateHTMLElement('div', reverbNameBox, 'reverbImportName', true);
const reverbImportClose = CreateHTMLElement('btn', reverbNameBox, 'reverbImportClose', true);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-remove');
    reverbImportClose.appendChild(i);
}
reverbImportClose.addEventListener('click', () => {
    impulseResponseBuffer = null;
    reverbConvolver.buffer = impulseResponseBuffer;

    //I'm deactivating the reverb because without the buffer no sound will come out
    reverbNode.SetMix(0);

    Animate(reverbImportClose, 'rotate', 250);
    setTimeout(() => {
        ChangeDisplay([reverbNameBox], 0);
        ChangeDisplay([reverbImportBtn], 1);
    }, 250);
});
function PlaceCloseButtonForReverbName(time = 10) {
    PlaceElement2(
        reverbImportName,
        reverbImportClose,
        time,
        (parent, child) => parent.offsetTop,
        (parent, child) => parent.offsetLeft + parent.offsetWidth
    );
}

ChangeDisplay([reverbImportInput, reverbNameBox], 0);

reverbImportBtn.addEventListener('click', () => {
    reverbImportInput.click();
});

reverbImportInput.addEventListener("change", async (event) => {
    const file = event.target.files[0];
    if (!file) {
        console.log("File withdrawn.");
        return;
    }

    const reader = new FileReader();

    reader.onload = async (e) => {
        const arrayBuffer = e.target.result;

        try {
            impulseResponseBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            reverbConvolver.buffer = impulseResponseBuffer;
            console.log("Impulse Response Buffer loaded !\n" + file.name + ' successfully loaded.');

            reverbImportName.textContent = file.name;

            Animate(reverbImportBtn, 'moveDown', 500);
            setTimeout(() => {
                ChangeDisplay([reverbImportBtn], 0);
                ChangeDisplay([reverbNameBox], 1);
                PlaceCloseButtonForReverbName();

                ChangeDisplay([recentWavFilesWindow], 0);
            }, 500);

            //Save to recentWavFiles
            const name = file.name;
            recentWavFiles.delete(name);
            recentWavFiles.set(name, file);
            if (recentWavFiles.size > 5) {
                const oldestKey = recentWavFiles.keys().next().value;
                recentWavFiles.delete(oldestKey);
            }
            UpdateRecentWavFilesWindow();

            const filteredEntries = await Promise.all(
                [...recentWavFiles].map(async ([name, file]) => {
                    const keep = await IsBlobPersistable(file.size, MAX_WAV_FILE_SIZE);
                    return keep ? [name, file] : null;
                })
            );

            const validEntries = filteredEntries.filter(entry => entry !== null);
            await wavStorage.SaveMap(new Map(validEntries));

            if (reverbMask.style.display == 'none') {
                //I'm activating the reverb if (and only if) a reverb buffer is input
                reverbNode.SetMix(reverbMix);
            }
        } catch (err) {
            console.error("Error decoding .wav file: ", err);
        }
    };

    reader.readAsArrayBuffer(file);
    reverbImportInput.value = '';
});

const reverbResetBtn = CreateHTMLElement('btn', reverbActivateBox, 'reverbResetBtn', true);
AttachTooltip(reverbResetBtn, 'Reset', 100);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-reply');
    reverbResetBtn.appendChild(i);
}
reverbResetBtn.addEventListener('click', () => {
    Animate(reverbResetBtn, 'rotate-left', 500);

    const intervalDelay = 10; //In ms

    const previousReverbFreq = reverbFreq;
    const previousReverbMix = reverbMix;

    const dimValue = intervalDelay / 500;
    let t = 0;
    const interval = setInterval(() => {
        reverbFreq = previousReverbFreq + (defaultReverbFreq - previousReverbFreq) * t;
        reverbMix = previousReverbMix + (defaultReverbMix - previousReverbMix) * t;

        DisplayReverbSlider(true);
        DisplayReverbSlider(false);
        UpdateReverbTexts();

        if (t > 1) clearInterval(interval);
        t += dimValue;
    }, intervalDelay);

    isSf2UsedForReverb = defaultIsSf2UsedForReverb == 1;
    ChangeReverbSf2BtnColor();

    reverbNode.SetHighFreq(defaultReverbFreq);
    reverbNode.SetMix(defaultReverbMix);

    localStorage.setItem('reverb', `1;${defaultReverbFreq};${defaultReverbMix};${defaultIsSf2UsedForReverb ? '1' : '0'}`);
});

const reverbActivateBtn = CreateHTMLElement('btn', reverbActivateBox, 'reverbActivateBtn', true);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-power-off');
    reverbActivateBtn.appendChild(i);
}
const reverbMask = CreateHTMLElement('div', reverbContent, 'reverbMask', true);
ChangeDisplay([reverbMask], parseInt(localStorage.getItem('reverb').split(';')[0]));
reverbActivateBtn.addEventListener('click', () => {
    if (reverbMask.style.display === 'flex') {
        ChangeDisplay([reverbMask], 0);

        if (reverbConvolver.buffer != null) {
            //I do that to NOT activate the reverb if there's no convolver input otherwise you may wonder why no sound is coming out
            reverbNode.SetMix(reverbMix);
        }

        const values = localStorage.getItem('reverb').split(';');
        const str = 0 + ';' + values[1] + ';' + values[2] + ';' + values[3];
        localStorage.setItem('reverb', str.toString());
    } else {
        ChangeDisplay([reverbMask], 1);

        reverbNode.SetMix(0);

        const values = localStorage.getItem('reverb').split(';');
        const str = 1 + ';' + values[1] + ';' + values[2] + ';' + values[3];
        localStorage.setItem('reverb', str.toString());
    }
});

let isSf2UsedForReverb = localStorage.getItem('reverb').split(';')[3] == '1';
const reverbSf2Btn = CreateHTMLElement('btn', reverbActivateBox, 'reverbSf2Btn', true);
AttachTooltip(reverbSf2Btn, ' Volume may vary due to SoundFont reverb settings.\nDisable for uniform sound.', 50);
function ChangeReverbSf2BtnColor() {
    const col = colors[isSf2UsedForReverb ? 0 : 1]
    reverbSf2Btn.style.backgroundColor = `rgba(${col[0]}, ${col[1]}, ${col[2]}, 1)`;
    reverbSf2Btn.style.boxShadow = `0 0 5px 2px rgba(${col[0]}, ${col[1]}, ${col[2]}, 1)`;
}
ChangeReverbSf2BtnColor();
reverbSf2Btn.addEventListener('click', () => {
    isSf2UsedForReverb = !isSf2UsedForReverb;

    const values = localStorage.getItem('reverb').split(';');
    const str = values[0] + ';' + values[1] + ';' + values[2] + ';' + (isSf2UsedForReverb ? 1 : 0);
    localStorage.setItem('reverb', str.toString());

    ChangeReverbSf2BtnColor();
});


const wavStorage = new Storage();
let recentWavFiles = new Map();

async function WavMain() {
    try {
        await wavStorage.Init("wavFiles", "wavMap");
        // console.log("Initialized WAV Base !"); //I don't want that to be written every time I launch my piano
    } catch (err) {
        console.error(err);
    }

    try {
        recentWavFiles = await wavStorage.LoadMap(true);
        // console.log("Wav files loaded :", recentWavFiles); //I don't want that to be written every time I launch my piano
    } catch (err) {
        console.warn("No files loaded from IndexedDB :", err);
    }

    requestAnimationFrame(UpdateRecentWavFilesWindow);
}
WavMain();

const recentWavFilesWindow = document.querySelector('#recentWavFilesWindow');
ChangeDisplay([recentWavFilesWindow], 0);
const WTTDRWFW = 100; //Waiting Time To Display Recent Wav Files Window
const WTTRRWFW = 100; //Waiting Time To Remove Recent Wav Files Window
let wavCloseTimer = null;

reverbImportBtn.addEventListener('mouseenter', () => {
    if (wavCloseTimer) clearTimeout(wavCloseTimer);

    if (recentWavFilesWindow.style.display === 'none' && recentWavFiles.size > 0) {
        setTimeout(() => {
            PlaceElement2(
                reverbImportBtn,
                recentWavFilesWindow,
                10,
                (parent, child) => parent.getBoundingClientRect().bottom + 5,
                (parent, child) => parent.getBoundingClientRect().left + parent.offsetWidth / 2 - child.offsetWidth / 2
            );

            ChangeDisplay([recentWavFilesWindow], 1);
        }, WTTDRWFW);
    }
});
recentWavFilesWindow.addEventListener('mouseenter', () => {
    if (wavCloseTimer) clearTimeout(wavCloseTimer);
});

reverbImportBtn.addEventListener('mouseleave', StartCloseTimerForReverb);
recentWavFilesWindow.addEventListener('mouseleave', StartCloseTimerForReverb);
function StartCloseTimerForReverb() {
    wavCloseTimer = setTimeout(() => {
        ChangeDisplay([recentWavFilesWindow], 0);
    }, WTTRRWFW);
}


function UpdateRecentWavFilesWindow() {
    if (recentWavFiles.size == 0) return;

    recentWavFilesWindow.innerHTML = '';

    for (const [name, file] of [...recentWavFiles.entries()].reverse()) {

        const row = document.createElement('div');
        row.classList.add('recentFilesRow');
        recentWavFilesWindow.appendChild(row);

        const text = document.createElement('div');
        text.classList.add('recentFilesName');
        text.textContent = name;
        row.appendChild(text);

        row.addEventListener('click', async () => {
            try {
                const arrayBuffer = await file.arrayBuffer();

                impulseResponseBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                reverbConvolver.buffer = impulseResponseBuffer;
                console.log("Impulse Response Buffer loaded !\n" + file.name + ' successfully loaded.');

                reverbImportName.textContent = file.name;

                Animate(reverbImportBtn, 'moveDown', 500);
                setTimeout(() => {
                    ChangeDisplay([reverbImportBtn], 0);
                    ChangeDisplay([reverbNameBox], 1);
                    PlaceCloseButtonForReverbName();
                }, 500);

                //Save to recentWavFiles
                const name = file.name;
                recentWavFiles.delete(name);
                recentWavFiles.set(name, file);
                if (recentWavFiles.size > 5) {
                    const oldestKey = recentWavFiles.keys().next().value;
                    recentWavFiles.delete(oldestKey);
                }
                UpdateRecentWavFilesWindow();

                const filteredEntries = await Promise.all(
                    [...recentWavFiles].map(async ([name, file]) => {
                        const keep = await IsBlobPersistable(file.size, MAX_WAV_FILE_SIZE);
                        return keep ? [name, file] : null;
                    })
                );

                const validEntries = filteredEntries.filter(entry => entry !== null);
                await wavStorage.SaveMap(new Map(validEntries));

                if (reverbMask.style.display == 'none') {
                    //I'm activating the reverb if (and only if) a reverb buffer is input
                    reverbNode.SetMix(reverbMix);
                }
            } catch (error) {
                console.error("Error decoding .wav file: ", error);
            }

            clearTimeout(wavCloseTimer);
            ChangeDisplay([recentWavFilesWindow], 0);
        });
    }

    PlaceElement2(
        reverbImportBtn,
        recentWavFilesWindow,
        10,
        (parent, child) => parent.getBoundingClientRect().bottom + 5,
        (parent, child) => parent.getBoundingClientRect().left + parent.offsetWidth / 2 - child.offsetWidth / 2
    );

    document.querySelector(`#recentWavFilesWindow > :last-child`).style.borderBottom = 'none';
}


document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 3) return;

    const key = event.code;
    if (key == 'Enter' || key == 'Space') {
        reverbActivateBtn.click();
    }
});


// _____________________________________________ Chorus ___________________________________________


const defaultChorusRate = 1.5;
const defaultChorusDepth = 0.0035;
const defaultChorusDelayTime = 0.015;
const defaultChorusMix = 0.4;
const defaultIsSf2UsedForChorus = 1;
if (!localStorage.getItem('chorus')) localStorage.setItem('chorus', `${defaultChorusRate};${defaultChorusDepth};${defaultChorusDelayTime};${defaultChorusMix};${defaultIsSf2UsedForChorus}`);

let chorusRate = parseFloat(localStorage.getItem('chorus').split(';')[0]); //LFO speed in Hz
let chorusDepth = parseFloat(localStorage.getItem('chorus').split(';')[1]); //Depth of modulation in seconds
let chorusDelayTime = parseFloat(localStorage.getItem('chorus').split(';')[2]); //Base delay time
let chorusMix = parseFloat(localStorage.getItem('chorus').split(';')[3]); //0 = dry, 1 = wet
let isSf2UsedForChorus = localStorage.getItem('chorus').split(';')[4] == '1';

const chorusInput = audioCtx.createGain();
const chorusOutput = audioCtx.createGain();

const chorusDryGain = audioCtx.createGain();
const chorusWetGain = audioCtx.createGain();
const chorusDelayNode = audioCtx.createDelay();
const chorusLfo = audioCtx.createOscillator();
const chorusLfoGain = audioCtx.createGain();
const chorusSendGain = audioCtx.createGain();

chorusInput.connect(chorusDryGain).connect(chorusOutput);
chorusInput.connect(chorusSendGain).connect(chorusDelayNode).connect(chorusWetGain).connect(chorusOutput);

// LFO  delayTime 
let lfoStarted = false;
window.addEventListener('click', () => {
    if (!lfoStarted) {
        chorusLfo.connect(chorusLfoGain).connect(chorusDelayNode.delayTime);
        chorusLfo.start();
        lfoStarted = true;
    }
});


const chorusNode = {
    input: chorusInput,
    output: chorusOutput,
    SetMix(mix) {
        chorusDryGain.gain.value = 1 - mix;
        chorusWetGain.gain.value = mix;
    },
    SetDelayTime(val) {
        chorusDelayNode.delayTime.value = val;
    },
    SetLfo(val) {
        chorusLfo.frequency.value = val;
    },
    SetLfoGain(val) {
        chorusLfoGain.gain.value = val;
    }
};

chorusNode.SetMix(0); //0 because at the lauching the chorus is deactivated
chorusNode.SetDelayTime(chorusDelayTime);
chorusNode.SetLfo(chorusRate);
chorusNode.SetLfoGain(chorusDepth);
chorusNode.output.connect(reverbNode.input);

const chorusContent = CreateHTMLElement('div', document.querySelector('#chorusScreen'), 'chorusContent', true);
const chorusTop = CreateHTMLElement('div', chorusContent, 'chorusTop', true);
const chorusSliders = CreateHTMLElement('div', chorusContent, 'chorusSliders', true);

const chorusTitle = document.querySelector('#chorusScreen').firstChild;
document.querySelector('#chorusScreen').removeChild(chorusTitle);
chorusTop.appendChild(chorusTitle);

const chorusActivateBtn = CreateHTMLElement('btn', chorusTop, 'chorusActivateBtn', true);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-power-off');
    chorusActivateBtn.appendChild(i);
}
const chorusMask = CreateHTMLElement('div', chorusContent, 'chorusMask', true);
ChangeDisplay([chorusMask], 1); //By default is disabled
chorusActivateBtn.addEventListener('click', () => {
    if (chorusMask.style.display === 'flex') {
        ChangeDisplay([chorusMask], 0);

        chorusNode.SetMix(chorusMix);
    } else {
        ChangeDisplay([chorusMask], 1);

        chorusNode.SetMix(0);
    }
});

const chorusResetBtn = CreateHTMLElement('btn', chorusTop, 'chorusResetBtn', true);
AttachTooltip(chorusResetBtn, 'Reset', 100);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-reply');
    chorusResetBtn.appendChild(i);
}
chorusResetBtn.addEventListener('click', () => {
    Animate(chorusResetBtn, 'rotate-left', 500);

    const intervalDelay = 10; //In ms

    const previousChorusRate = chorusRate;
    const previousChorusDepth = chorusDepth;
    const previousChorusDelayTime = chorusDelayTime;
    const previousChorusMix = chorusMix;

    const dimValue = intervalDelay / 500;
    let t = 0;
    const interval = setInterval(() => {
        chorusRate = previousChorusRate + (defaultChorusRate - previousChorusRate) * t;
        chorusDepth = previousChorusDepth + (defaultChorusDepth - previousChorusDepth) * t;
        chorusDelayTime = previousChorusDelayTime + (defaultChorusDelayTime - previousChorusDelayTime) * t;
        chorusMix = previousChorusMix + (defaultChorusMix - previousChorusMix) * t;

        for (let i = 0; i < 4; i++) DisplayChorusSlider(i);
        UpdateChorusTexts();

        if (t > 1) clearInterval(interval);
        t += dimValue;
    }, intervalDelay);

    isSf2UsedForChorus = defaultIsSf2UsedForChorus == 1;
    ChangeChorusSf2BtnColor();

    chorusNode.SetLfo(defaultChorusRate);
    chorusNode.SetLfoGain(defaultChorusDepth);
    chorusNode.SetDelayTime(defaultChorusDelayTime);
    chorusNode.SetMix(defaultChorusMix);

    localStorage.setItem('chorus', `${defaultChorusRate};${defaultChorusDepth};${defaultChorusDelayTime};${defaultChorusMix};${defaultIsSf2UsedForChorus ? '1' : '0'}`);
});

const chorusSf2Btn = CreateHTMLElement('btn', chorusTop, 'chorusSf2Btn', true);
AttachTooltip(chorusSf2Btn, ' Volume may vary due to SoundFont chorus settings.\nDisable for uniform sound.', 50);
function ChangeChorusSf2BtnColor() {
    const col = colors[isSf2UsedForChorus ? 0 : 1]
    chorusSf2Btn.style.backgroundColor = `rgba(${col[0]}, ${col[1]}, ${col[2]}, 1)`;
    chorusSf2Btn.style.boxShadow = `0 0 5px 2px rgba(${col[0]}, ${col[1]}, ${col[2]}, 1)`;
}
ChangeChorusSf2BtnColor();
chorusSf2Btn.addEventListener('click', () => {
    isSf2UsedForChorus = !isSf2UsedForChorus;

    const values = localStorage.getItem('chorus').split(';');
    const str = values[0] + ';' + values[1] + ';' + values[2] + ';' + values[3] + ';' + (isSf2UsedForChorus ? 1 : 0);
    localStorage.setItem('chorus', str.toString());

    ChangeChorusSf2BtnColor();
});

const chorusTopSliders = CreateHTMLElement('div', chorusSliders, 'chorusTopSliders', true);
const chorusBottomSliders = CreateHTMLElement('div', chorusSliders, 'chorusBottomSliders', true);

const chorusRateBox = CreateHTMLElement('div', chorusTopSliders, 'chorusRateBox', true);
const chorusDepthBox = CreateHTMLElement('div', chorusTopSliders, 'chorusDepthBox', true);
const chorusDelayTimeBox = CreateHTMLElement('div', chorusBottomSliders, 'chorusDelayTimeBox', true);
const chorusMixBox = CreateHTMLElement('div', chorusBottomSliders, 'chorusMixBox', true);

const chorusRateTitle = CreateHTMLElement('div', chorusRateBox, 'chorusRateTitle', true);
const chorusDepthTitle = CreateHTMLElement('div', chorusDepthBox, 'chorusDepthTitle', true);
const chorusDelayTimeTitle = CreateHTMLElement('div', chorusDelayTimeBox, 'chorusDelayTimeTitle', true);
const chorusMixTitle = CreateHTMLElement('div', chorusMixBox, 'chorusMixTitle', true);
chorusRateTitle.textContent = 'Rate';
chorusDepthTitle.textContent = 'Depth';
chorusDelayTimeTitle.textContent = 'Delay Time';
chorusMixTitle.textContent = 'Mix';

const chorusRateValue = CreateHTMLElement('div', chorusRateBox, 'chorusRateValue', true);
const chorusDepthValue = CreateHTMLElement('div', chorusDepthBox, 'chorusDepthValue', true);
const chorusDelayTimeValue = CreateHTMLElement('div', chorusDelayTimeBox, 'chorusDelayTimeValue', true);
const chorusMixValue = CreateHTMLElement('div', chorusMixBox, 'chorusMixValue', true);


const chorusRateTrueValue = CreateHTMLElement('div', chorusRateBox, 'chorusRateTrueValue', true);
const chorusDepthTrueValue = CreateHTMLElement('div', chorusDepthBox, 'chorusDepthTrueValue', true);
const chorusDelayTimeTrueValue = CreateHTMLElement('div', chorusDelayTimeBox, 'chorusDelayTimeTrueValue', true);
const chorusMixTrueValue = CreateHTMLElement('div', chorusMixBox, 'chorusMixTrueValue', true);

function UpdateChorusTexts() {
    {
        {
            const value = Math.round(((chorusRate - .1) / 4.9) * 100) / 100;
            const length = value.toString().length;
            chorusRateValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        }
        {
            const value = Math.round((chorusDepth * 1000 / 5) * 100) / 100;
            const length = value.toString().length;
            chorusDepthValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        }
        {
            const value = Math.round(((chorusDelayTime * 1000 - 5) / 25) * 100) / 100;
            const length = value.toString().length;
            chorusDelayTimeValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        }
        {
            const value = Math.round(chorusMix * 100) / 100;
            const length = value.toString().length;
            chorusMixValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        }
    }

    {
        {
            const value = Math.round(chorusRate * 10) / 10;
            chorusRateTrueValue.textContent = value + ' Hz';
        }
        {
            const value = Math.round((chorusDepth * 1000) * 10) / 10;
            chorusDepthTrueValue.textContent = value + ' ms';
        }
        {
            const value = Math.round(chorusDelayTime * 1000);
            const trueLength = value.toString().length;
            chorusDelayTimeTrueValue.textContent = (trueLength == 1 ? '0' + value : value) + ' ms';
        }
        {
            const value = Math.round(chorusMix * 100);
            chorusMixTrueValue.textContent = value + ' %';
        }
    }
}
UpdateChorusTexts();

function DisplayChorusSlider(slider) {
    let chorusBox, id;
    if (slider == 0) {
        chorusBox = chorusRateBox;
        id = 'chorusRateSVG';
    } else if (slider == 1) {
        chorusBox = chorusDepthBox;
        id = 'chorusDepthSVG';
    } else if (slider == 2) {
        chorusBox = chorusDelayTimeBox;
        id = 'chorusDelayTimeSVG';
    } else if (slider == 3) {
        chorusBox = chorusMixBox;
        id = 'chorusMixSVG';
    }
    const width = chorusBox.clientWidth;
    const height = chorusBox.clientHeight;

    const chorusSVG = document.createElementNS(svgNS, "svg");
    chorusSVG.id = id;
    chorusSVG.setAttribute("viewBox", `0 0 ${width} ${height}`);
    chorusSVG.setAttribute("width", "100%");
    chorusSVG.setAttribute("height", "100%");
    chorusBox.appendChild(chorusSVG);
    chorusSVG.style.display = 'block';

    const arcPath = CreateChorusPath(width, height);

    const sliderPath = document.createElementNS(svgNS, "path");
    sliderPath.setAttribute('d', arcPath);
    sliderPath.setAttribute('stroke', '#888');
    sliderPath.setAttribute('stroke-width', '4');
    sliderPath.setAttribute('fill', 'none');

    chorusSVG.appendChild(sliderPath);

    DisplayChorusSlider2(chorusSVG, chorusBox, slider);

    const children = Array.from(chorusBox.children);
    for (const child of children) {
        if (child.namespaceURI === svgNS) {
            chorusBox.removeChild(child);
        }
    }
    chorusBox.appendChild(chorusSVG);
}
function ChorusFunction(x) {
    let y = Math.sin(x);

    return y;
}
function CreateChorusPath(width, height, completion = 1, steps = 60) {
    const startX = width * 0.1;
    const usableWidth = width * 0.8;
    const startY = height / 2;
    const amplitude = height * 0.25;

    let d = `M ${startX} ${startY}`;

    for (let i = 0; i <= steps; i++) {
        const t = i / steps; //0  1
        if (t > completion) break;
        const x = startX + usableWidth * t;
        const angle = t * 2 * Math.PI; //0  2 (for the beauty)
        const y = startY - ChorusFunction(angle) * amplitude;

        d += ` L ${x} ${y}`;
    }

    return d;
}
function DisplayChorusSlider2(chorusSVG, chorusBox, slider) {
    let value;
    if (slider == 0) {
        value = chorusRate;

        value = (value - .1) / 4.9; //Back to a value between 0 and 1
    } else if (slider == 1) {
        value = chorusDepth;

        value *= 1000; //In ms
        value /= 5; //Back to a value between 0 and 1
    } else if (slider == 2) {
        value = chorusDelayTime;

        value *= 1000; //In ms
        value = (value - 5) / 25; //Back to a value between 0 and 1
    } else if (slider == 3) {
        value = chorusMix; //It's already between 0 and 1
    }

    const width = chorusBox.clientWidth;
    const height = chorusBox.clientHeight;

    const activeArc = document.createElementNS(svgNS, "path");
    const activePath = CreateChorusPath(width, height, value);
    activeArc.setAttribute('d', activePath);
    activeArc.setAttribute('stroke', `rgba(255, ${96 + (192 - 96) * (1 - value)}, ${96 + (192 - 96) * (1 - value)}, 1)`);
    activeArc.setAttribute('stroke-width', '6');
    activeArc.setAttribute('fill', 'none');

    const endX = width * .1 + width * .8 * value;
    const endY = height / 2 - ChorusFunction(value * 2 * Math.PI) * height * .25;

    const handle = document.createElementNS(svgNS, 'circle');
    handle.setAttribute('cx', endX);
    handle.setAttribute('cy', endY);
    handle.setAttribute('r', '8');
    handle.setAttribute('fill', 'rgba(255, 96, 96, 1)');
    handle.setAttribute('stroke', '#fff');
    handle.setAttribute('stroke-width', '2');

    if (chorusDragging.state && slider == chorusDragging.slider) handle.style.cursor = 'grabbing';

    let isChorusMouseleaveAttached = false;
    handle.addEventListener('mousedown', () => {
        if (effectsContainer.style.display !== 'none' && currentPage === 4) {
            chorusDragging = {
                state: true,
                slider: slider
            };

            chorusSVG.style.cursor = 'grabbing';
            handle.style.cursor = 'grabbing';

            if (!isChorusMouseleaveAttached) {
                isChorusMouseleaveAttached = true;

                chorusSVG.addEventListener('mouseleave', () => {
                    if (!chorusDragging.state) return;
                    else if (chorusDragging.slider !== slider) return;
    
                    chorusDragging.state = false;
                    chorusSVG.style.cursor = 'auto';
                    handle.style.cursor = 'grab';
                });
            }
        }
    });

    chorusSVG.appendChild(activeArc);
    chorusSVG.appendChild(handle);
}


let chorusDragging = { state: false, slider: 0 };
function ChorusOnMouseMove(e) {
    if (effectsContainer.style.display == 'none' || currentPage != 4 || !chorusDragging.state) return;

    let chorusSVG, chorusBox;
    if (chorusDragging.slider == 0) {
        chorusSVG = document.querySelector('#chorusRateSVG');
        chorusBox = chorusRateBox;
    } else if (chorusDragging.slider == 1) {
        chorusSVG = document.querySelector('#chorusDepthSVG');
        chorusBox = chorusDepthBox;
    } else if (chorusDragging.slider == 2) {
        chorusSVG = document.querySelector('#chorusDelayTimeSVG');
        chorusBox = chorusDelayTimeBox;
    } else if (chorusDragging.slider == 3) {
        chorusSVG = document.querySelector('#chorusMixSVG');
        chorusBox = chorusMixBox;
    }

    const width = chorusBox.clientWidth;

    const rect = chorusBox.getBoundingClientRect();
    const cx = rect.left + width * 0.1;

    const dx = e.clientX - cx;

    let value = dx / (width * .8); //Value between 0 and 1

    if (chorusDragging.slider == 0) {
        value = Math.round(value * 100) / 100 //Round 2 digits after comma
        value = Math.min(Math.max(0, value), 1); //Clamp between 0 and 1

        let trueValue = (.1 + 4.9 * value); //true value with lots of decimals

        chorusRate = trueValue;
        chorusNode.SetLfo(chorusRate);

        trueValue = Math.round(trueValue * 10) / 10; //true value with one decimal for displaying

        const length = value.toString().length;
        chorusRateValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

        chorusRateTrueValue.textContent = trueValue + ' Hz';

        const values = localStorage.getItem('chorus').split(';');
        const str = chorusRate + ';' + values[1] + ';' + values[2] + ';' + values[3] + ';' + values[4];
        localStorage.setItem('chorus', str.toString());
    } else if (chorusDragging.slider == 1) {
        value = Math.round(value * 100) / 100 //Round 2 digits after comma
        value = Math.min(Math.max(0, value), 1); //Clamp between 0 and 1

        let trueValue = 5 * value; //true value with lots of decimals

        chorusDepth = trueValue / 1000;
        chorusNode.SetLfoGain(chorusDepth);

        trueValue = Math.round(trueValue * 10) / 10; //true value with one decimal for displaying

        const length = value.toString().length;
        chorusDepthValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

        chorusDepthTrueValue.textContent = trueValue + ' ms';

        const values = localStorage.getItem('chorus').split(';');
        const str = values[0] + ';' + chorusDepth + ';' + values[2] + ';' + values[3] + ';' + values[4];
        localStorage.setItem('chorus', str.toString());
    } else if (chorusDragging.slider == 2) {
        value = Math.round(value * 100) / 100 //Round 2 digits after comma
        value = Math.min(Math.max(0, value), 1); //Clamp between 0 and 1

        let trueValue = 5 + 25 * value; //true value with lots of decimals

        chorusDelayTime = trueValue / 1000;
        chorusNode.SetDelayTime(chorusDelayTime);

        trueValue = Math.round(trueValue); //true value with no decimal for displaying

        const length = value.toString().length;
        chorusDelayTimeValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

        const trueLength = trueValue.toString().length;
        chorusDelayTimeTrueValue.textContent = (trueLength == 1 ? '0' + trueValue : trueValue) + ' ms';

        const values = localStorage.getItem('chorus').split(';');
        const str = values[0] + ';' + values[1] + ';' + chorusDelayTime + ';' + values[3] + ';' + values[4];
        localStorage.setItem('chorus', str.toString());
    } else if (chorusDragging.slider == 3) {
        value = Math.round(value * 100) / 100; //Round 2 digits after comma
        value = Math.min(Math.max(0, value), 1); //Clamp between 0 and 1

        const trueValue = Math.round(value * 100);

        chorusMix = value;
        chorusNode.SetMix(chorusMix);

        const length = value.toString().length;
        chorusMixValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

        chorusMixTrueValue.textContent = trueValue + ' %';

        const values = localStorage.getItem('chorus').split(';');
        const str = values[0] + ';' + values[1] + ';' + values[2] + ';' + chorusMix + ';' + values[4];
        localStorage.setItem('chorus', str.toString());
    }

    for (let _ = 0; _ < 2; _++) chorusSVG.removeChild(chorusSVG.lastChild);
    DisplayChorusSlider2(chorusSVG, chorusBox, chorusDragging.slider);
}

function ChorusOnMouseUp() {
    if (!chorusDragging.state) return;
    chorusDragging.state = false;

    document.querySelector('#chorusRateSVG').style.cursor = 'auto';
    document.querySelector('#chorusDepthSVG').style.cursor = 'auto';
    document.querySelector('#chorusDelayTimeSVG').style.cursor = 'auto';
    document.querySelector('#chorusMixSVG').style.cursor = 'auto';

    document.querySelector('#chorusRateSVG circle').style.cursor = 'grab';
    document.querySelector('#chorusDepthSVG circle').style.cursor = 'grab';
    document.querySelector('#chorusDelayTimeSVG circle').style.cursor = 'grab';
    document.querySelector('#chorusMixSVG circle').style.cursor = 'grab';
}


document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 4) return;

    const key = event.code;
    if (key == 'Enter' || key == 'Space') {
        chorusActivateBtn.click();
    }
});


// _____________________________________________ ADSR _____________________________________________


const defaultAdsrAttack = 0.1;
const defaultAdsrHold = 0.2;
const defaultAdsrDecay = 0.1;
const defaultAdsrSustain = 0.7;
const defaultAdsrRelease = 0.3;
if (!localStorage.getItem('adsr')) localStorage.setItem('adsr', `${defaultAdsrAttack};${defaultAdsrHold};${defaultAdsrDecay};${defaultAdsrSustain};${defaultAdsrRelease}`);
const adsrValues = localStorage.getItem('adsr').split(';');
let adsrAttack = parseFloat(adsrValues[0]); //Time in second
let adsrHold = parseFloat(adsrValues[1]); //Time in second
let adsrDecay = parseFloat(adsrValues[2]); //Time in second
let adsrSustain = parseFloat(adsrValues[3]); //Value between 0 and 1
let adsrRelease = parseFloat(adsrValues[4]); //Time in second

let isAdsrUse = false; //False by default. So disabled.

const adsrContent = CreateHTMLElement('div', document.querySelector('#adsrScreen'), 'adsrContent', true);

const adsrTop = CreateHTMLElement('div', adsrContent, 'adsrTop', true);
const adsrBottom = CreateHTMLElement('div', adsrContent, 'adsrBottom', true);

const adsrTitle = document.querySelector('#adsrScreen').firstChild;
document.querySelector('#adsrScreen').removeChild(adsrTitle);
adsrTop.appendChild(adsrTitle);

const adsrActivateBtn = CreateHTMLElement('btn', adsrTop, 'adsrActivateBtn', true);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-power-off');
    adsrActivateBtn.appendChild(i);
}
const adsrMask = CreateHTMLElement('div', adsrContent, 'adsrMask', true);
ChangeDisplay([adsrMask], isAdsrUse ? 0 : 1);
adsrActivateBtn.addEventListener('click', () => {
    if (isAdsrUse) {
        ChangeDisplay([adsrMask], 1);
    } else {
        ChangeDisplay([adsrMask], 0);
    }

    isAdsrUse = !isAdsrUse;
});

const adsrResetBtn = CreateHTMLElement('btn', adsrTop, 'adsrResetBtn', true);
AttachTooltip(adsrResetBtn, 'Reset', 100);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-reply');
    adsrResetBtn.appendChild(i);
}
adsrResetBtn.addEventListener('click', () => {
    Animate(adsrResetBtn, 'rotate-left', 500);

    const intervalDelay = 10; //In ms
    const adsrSVG = document.querySelector('#adsrSVG');

    const previousAdsrAttack = adsrAttack;
    const previousAdsrHold = adsrHold;
    const previousAdsrDecay = adsrDecay;
    const previousAdsrSustain = adsrSustain;
    const previousAdsrRelease = adsrRelease;

    const dimValue = intervalDelay / 500;
    let t = 0;
    const interval = setInterval(() => {
        adsrAttack = previousAdsrAttack + (defaultAdsrAttack - previousAdsrAttack) * t;
        adsrHold = previousAdsrHold + (defaultAdsrHold - previousAdsrHold) * t;
        adsrDecay = previousAdsrDecay + (defaultAdsrDecay - previousAdsrDecay) * t;
        adsrSustain = previousAdsrSustain + (defaultAdsrSustain - previousAdsrSustain) * t;
        adsrRelease = previousAdsrRelease + (defaultAdsrRelease - previousAdsrRelease) * t;

        UpdateAdsrTexts();
        for (let _ = 0; _ < 9; _++) adsrSVG.removeChild(adsrSVG.lastChild);
        DisplayADSRCurve(adsrSVG);

        if (t > 1) clearInterval(interval);
        t += dimValue;
    }, intervalDelay);

    localStorage.setItem('adsr', `${defaultAdsrAttack};${defaultAdsrHold};${defaultAdsrDecay};${defaultAdsrSustain};${defaultAdsrRelease}`);
});

let adsrDragging = { state: false, setting: 0 };
const adsrPadding = 0.1;
const adsrEpsilon = 0.001;
function DisplayADSR() {
    const width = adsrBottom.clientWidth;
    const height = adsrBottom.clientHeight;

    const startX = width * adsrPadding;
    const startY = height * (1 - adsrPadding);

    const AS = 15; //short for Arrow Size (because I use it often so it's easier...)

    const color1 = "#8041a8";

    const adsrSVG = document.createElementNS(svgNS, "svg");
    adsrSVG.id = 'adsrSVG';
    adsrSVG.setAttribute("viewBox", `0 0 ${width} ${height}`);
    adsrSVG.setAttribute("width", "100%");
    adsrSVG.setAttribute("height", "100%");
    adsrBottom.appendChild(adsrSVG);
    adsrSVG.style.display = 'block';

    const XAxis = document.createElementNS(svgNS, "path");
    XAxis.setAttribute("id", "XAxis");
    XAxis.setAttribute("stroke", color1);
    XAxis.setAttribute("stroke-width", "2");
    XAxis.setAttribute("d", `M ${startX},${height * adsrPadding / 2} L ${startX},${height * (1 - adsrPadding / 2)}`);
    adsrSVG.appendChild(XAxis);

    const AUSY = height * adsrPadding / 2 - AS / 2; //short for Arrow Up Spike Y
    const arrowUp = document.createElementNS(svgNS, "polygon");
    arrowUp.setAttribute("points", `${startX},${AUSY} ${startX - AS / 2},${AUSY + AS} ${startX + AS / 2},${AUSY + AS}`);
    arrowUp.setAttribute("fill", color1);
    adsrSVG.appendChild(arrowUp);

    const YAxis = document.createElementNS(svgNS, "path");
    YAxis.setAttribute("id", "YAxis");
    YAxis.setAttribute("stroke", color1);
    YAxis.setAttribute("stroke-width", "2");
    YAxis.setAttribute("d", `M ${width * adsrPadding / 2},${startY} L ${width * (1 - adsrPadding / 2)},${startY}`);
    adsrSVG.appendChild(YAxis);

    const ARSX = width * (1 - adsrPadding / 2) + AS / 2; //short for Arrow Right Spike X
    const arrowRight = document.createElementNS(svgNS, "polygon");
    arrowRight.setAttribute("points", `${ARSX},${startY} ${ARSX - AS},${startY - AS / 2} ${ARSX - AS},${startY + AS / 2}`);
    arrowRight.setAttribute("fill", color1);
    adsrSVG.appendChild(arrowRight);

    DisplayADSRCurve(adsrSVG);

    const children = Array.from(adsrBottom.children);
    for (const child of children) {
        if (child.namespaceURI === svgNS) {
            adsrBottom.removeChild(child);
        }
    }
    adsrBottom.appendChild(adsrSVG);
}
function DisplayADSRCurve(adsrSVG) {
    const width = adsrBottom.clientWidth;
    const height = adsrBottom.clientHeight;

    const usableWidth = width * (1 - adsrPadding * 2);
    const adsrLength = usableWidth / 10; //The usableWidth count for 10 seconds so in order to have right positions, I'm dividing by 10 for future uses
    const usableHeight = height * (1 - adsrPadding * 2);

    CreateAdsrCurve(adsrSVG, 0); //attackCurve
    CreateAdsrCurve(adsrSVG, 1); //holdCurve
    CreateAdsrCurve(adsrSVG, 2); //decayCurve
    CreateAdsrCurve(adsrSVG, 3); //sustainCurve
    CreateAdsrCurve(adsrSVG, 4); //releaseCurve

    CreateADSRKnob(0, adsrSVG, adsrLength * adsrAttack, usableHeight); //attackKnob
    CreateADSRKnob(1, adsrSVG, adsrLength * (adsrAttack + adsrHold), usableHeight); //holdKnob
    CreateADSRKnob(2, adsrSVG, adsrLength * (adsrAttack + adsrHold + adsrDecay), usableHeight * adsrSustain); //decayKnob
    CreateADSRKnob(3, adsrSVG, adsrLength * (10 - adsrRelease), usableHeight * adsrSustain); //releaseKnob
}
function CreateADSRKnob(index, adsrSVG, dx, dy) {
    const width = adsrBottom.clientWidth;
    const height = adsrBottom.clientHeight;

    const startX = width * adsrPadding;
    const startY = height * (1 - adsrPadding);

    const color3 = "#e09ed4";

    const knob = document.createElementNS(svgNS, 'circle');
    knob.setAttribute('cx', startX + dx);
    knob.setAttribute('cy', startY - dy);
    knob.setAttribute('r', '5');
    knob.setAttribute('fill', color3);
    knob.setAttribute('stroke', '#fff');
    knob.setAttribute('stroke-width', '2');
    adsrSVG.appendChild(knob);

    if (adsrDragging.state && adsrDragging.setting == index) knob.style.cursor = 'grabbing';

    let isAdsrMouseleaveAttached = false;
    knob.addEventListener('mousedown', () => {
        if (effectsContainer.style.display !== 'none' && currentPage === 5) {
            adsrDragging = {
                state: true,
                setting: index
            };

            adsrSVG.style.cursor = 'grabbing';
            knob.style.cursor = 'grabbing';

            if (!isAdsrMouseleaveAttached) {
                isAdsrMouseleaveAttached = true;

                adsrSVG.addEventListener('mouseleave', () => {
                    if (!adsrDragging.state) return;
                    else if (adsrDragging.setting !== index) return;

                    adsrDragging.state = false;
                    adsrSVG.style.cursor = 'auto';

                    document.querySelectorAll('#adsrSVG circle').forEach((knob) => { knob.style.cursor = 'grab'; });
                });
            }
        }
    });
}


function CreateAdsrCurve(adsrSVG, index, steps = 60) {
    let value, offsetX;
    if (index == 0) {
        value = adsrAttack;
        offsetX = 0;
    } else if (index == 1) {
        value = adsrHold;
        offsetX = adsrAttack;
    } else if (index == 2) {
        value = adsrDecay;
        offsetX = adsrAttack + adsrHold;
    } else if (index == 3) {
        offsetX = adsrAttack + adsrHold + adsrDecay;
        value = (10 - adsrRelease) - offsetX; //I put this one under the offset because I need the offsetX
    } else if (index == 4) {
        value = adsrRelease;
        offsetX = 10 - adsrRelease;
    }

    const width = adsrBottom.clientWidth;
    const height = adsrBottom.clientHeight;

    const startX = width * adsrPadding;
    const startY = height * (1 - adsrPadding);

    const usableWidth = width * (1 - adsrPadding * 2);
    const adsrLength = usableWidth / 10;
    const usableHeight = height * (1 - adsrPadding * 2);

    const color2 = "#408"; // Previous value that wasn't as good as I wanted but I keep it : #a061d8

    let path = `M ${startX + adsrLength * offsetX} ${startY - usableHeight * AdsrFunction(offsetX, index)}`;

    for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const x = value * t + offsetX;
        const y = startY - usableHeight * AdsrFunction(x, index);

        path += ` L ${startX + adsrLength * x} ${y}`;
    }

    const curve = document.createElementNS(svgNS, 'path');
    curve.setAttribute('d', path);
    curve.setAttribute('stroke', color2);
    curve.setAttribute('stroke-width', '4');
    curve.setAttribute('fill', 'none');
    adsrSVG.appendChild(curve);
}
function AdsrFunction(x, index) {
    let y = 0;

    if (index == 0) {
        y = Math.exp(Math.LN2 / adsrAttack * x) - 1;
    } else if (index == 1) {
        y = 1;
    } else if (index == 2) {
        y = Math.exp(Math.log(adsrSustain) / adsrDecay * (x - adsrAttack - adsrHold));
    } else if (index == 3) {
        y = adsrSustain;
    } else if (index == 4) {
        y = Math.exp(Math.log(1 - adsrSustain) / adsrRelease * (x - (10 - adsrRelease))) - (1 - adsrSustain);
    }

    return y;
}

function AdsrOnMouseUp() {
    if (!adsrDragging.state) return;
    adsrDragging.state = false;

    document.querySelector('#adsrSVG').style.cursor = 'auto';

    document.querySelectorAll('#adsrSVG circle').forEach((knob) => { knob.style.cursor = 'grab'; });
}


function AdsrOnMouseMove(e) {
    if (effectsContainer.style.display == 'none' || currentPage != 5 || !adsrDragging.state) return;

    const adsrSVG = document.querySelector('#adsrSVG');

    const width = adsrBottom.clientWidth;
    const height = adsrBottom.clientHeight;

    const startX = width * adsrPadding;
    const startY = height * (1 - adsrPadding);

    const usableWidth = width * (1 - adsrPadding * 2);
    const adsrLength = usableWidth / 10;
    const usableHeight = height * (1 - adsrPadding * 2);

    const rect = adsrBottom.getBoundingClientRect();
    const cx = rect.left + startX;
    const cy = rect.top + startY;

    const dx = e.clientX - cx;
    const dy = e.clientY - cy;

    if (adsrDragging.setting == 0) {
        let value = dx / adsrLength;
        value = Math.min(Math.max(adsrEpsilon, value), 2);

        adsrAttack = value;

        const values = localStorage.getItem('adsr').split(';');
        const str = adsrAttack + ';' + values[1] + ';' + values[2] + ';' + values[3] + ';' + values[4];
        localStorage.setItem('adsr', str.toString());
    } else if (adsrDragging.setting == 1) {
        let value = dx / adsrLength - adsrAttack;
        value = Math.min(Math.max(adsrEpsilon, value), 2);

        adsrHold = value;

        const values = localStorage.getItem('adsr').split(';');
        const str = values[0] + ';' + adsrHold + ';' + values[2] + ';' + values[3] + ';' + values[4];
        localStorage.setItem('adsr', str.toString());
    } else if (adsrDragging.setting == 2) {
        let value1 = dx / adsrLength - (adsrAttack + adsrHold);
        let value2 = - dy / usableHeight;

        value1 = Math.min(Math.max(adsrEpsilon, value1), 2);
        value2 = Math.min(Math.max(adsrEpsilon, value2), 1 - adsrEpsilon);

        adsrDecay = value1;
        adsrSustain = value2;

        const values = localStorage.getItem('adsr').split(';');
        const str = values[0] + ';' + values[1] + ';' + adsrDecay + ';' + adsrSustain + ';' + values[4];
        localStorage.setItem('adsr', str.toString());
    } else if (adsrDragging.setting == 3) {
        let value1 = 10 - dx / adsrLength;
        let value2 = - dy / usableHeight;

        value1 = Math.min(Math.max(adsrEpsilon, value1), 2);
        value2 = Math.min(Math.max(adsrEpsilon, value2), 1 - adsrEpsilon);

        adsrRelease = value1;
        adsrSustain = value2;

        const values = localStorage.getItem('adsr').split(';');
        const str = values[0] + ';' + values[1] + ';' + values[2] + ';' + adsrSustain + ';' + adsrRelease;
        localStorage.setItem('adsr', str.toString());
    }

    UpdateAdsrTexts();
    for (let _ = 0; _ < 9; _++) adsrSVG.removeChild(adsrSVG.lastChild);
    DisplayADSRCurve(adsrSVG);
}

const adsrAttackText = CreateHTMLElement('div', adsrBottom, 'adsrAttackText', true);
const adsrHoldText = CreateHTMLElement('div', adsrBottom, 'adsrHoldText', true);
const adsrDecayText = CreateHTMLElement('div', adsrBottom, 'adsrDecayText', true);
const adsrSustainText = CreateHTMLElement('div', adsrBottom, 'adsrSustainText', true);
const adsrReleaseText = CreateHTMLElement('div', adsrBottom, 'adsrReleaseText', true);
function UpdateAdsrTexts() {
    {
        adsrAttackText.textContent = 'Attack: ';

        const value = Math.round(adsrAttack * 100) / 100;
        const length = value.toString().length;
        adsrAttackText.textContent += length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        adsrAttackText.textContent += ' s';
    }
    {
        adsrHoldText.textContent = 'Hold: ';

        const value = Math.round(adsrHold * 100) / 100;
        const length = value.toString().length;
        adsrHoldText.textContent += length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        adsrHoldText.textContent += ' s';
    }
    {
        adsrDecayText.textContent = 'Decay: ';

        const value = Math.round(adsrDecay * 100) / 100;
        const length = value.toString().length;
        adsrDecayText.textContent += length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        adsrDecayText.textContent += ' s';
    }
    {
        adsrSustainText.textContent = 'Sustain: ';

        const value = Math.round(adsrSustain * 100);
        const length = value.toString().length;
        adsrSustainText.textContent += value;
        adsrSustainText.textContent += ' %';
    }
    {
        adsrReleaseText.textContent = 'Release: ';

        const value = Math.round(adsrRelease * 100) / 100;
        const length = value.toString().length;
        adsrReleaseText.textContent += length == 3 ? value + '0' : length == 1 ? value + '.00' : value;
        adsrReleaseText.textContent += ' s';
    }
}
UpdateAdsrTexts();


document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 5) return;

    const key = event.code;
    if (key == 'Enter' || key == 'Space') {
        adsrActivateBtn.click();
    }
});


// _____________________________________________ Echo _____________________________________________


const defaultEchoDelay = 0.2;
const defaultEchoFeedback = 0.5;
const defaultEchoMix = 0.4;
if (!localStorage.getItem('echo')) localStorage.setItem('echo', `${defaultEchoDelay};${defaultEchoFeedback};${defaultEchoMix}`);

const echoValues = localStorage.getItem('echo').split(';');
let echoDelay = parseFloat(echoValues[0]);
let echoFeedback = parseFloat(echoValues[1]);
let echoMix = parseFloat(echoValues[2]);


const echoInput = audioCtx.createGain();
const echoOutput = audioCtx.createGain();

const echoDelayNode = audioCtx.createDelay();
const echoDryGain = audioCtx.createGain();
const echoWetGain = audioCtx.createGain();
const echoFeedbackGain = audioCtx.createGain(); //Feedback loop

//Dry path
echoInput.connect(echoDryGain).connect(echoOutput);

//Wet path
echoInput.connect(echoDelayNode);
echoDelayNode.connect(echoFeedbackGain).connect(echoDelayNode); //Feedback loop
echoDelayNode.connect(echoWetGain).connect(echoOutput);

const echoNode = {
    input: echoInput,
    output: echoOutput,
    SetMix(mix) {
        echoDryGain.gain.value = 1 - mix;
        echoWetGain.gain.value = mix;
    },
    SetDelay(val) {
        echoDelayNode.delayTime.value = val;
    },
    SetFeedback(val) {
        echoFeedbackGain.gain.value = val;
    }
};

//Initialization
echoNode.SetMix(0); //Deactivated at the beginning
echoNode.SetDelay(echoDelay);
echoNode.SetFeedback(echoFeedback);

//Output to the others effects
echoNode.output.connect(chorusNode.input);

const echoContent = CreateHTMLElement('div', document.querySelector('#echoScreen'), 'echoContent', true);

const echoTop = CreateHTMLElement('div', echoContent, 'echoTop', true);
const echoSliders = CreateHTMLElement('div', echoContent, 'echoSliders', true);

const echoTitle = document.querySelector('#echoScreen').firstChild;
document.querySelector('#echoScreen').removeChild(echoTitle);
echoTop.appendChild(echoTitle);

const echoActivateBtn = CreateHTMLElement('btn', echoTop, 'echoActivateBtn', true);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-power-off');
    echoActivateBtn.appendChild(i);
}
const echoMask = CreateHTMLElement('div', echoContent, 'echoMask', true);
ChangeDisplay([echoMask], 1); //By default it's deactivated
echoActivateBtn.addEventListener('click', () => {
    if (echoMask.style.display === 'flex') {
        ChangeDisplay([echoMask], 0);

        echoNode.SetMix(echoMix);
    } else {
        ChangeDisplay([echoMask], 1);

        echoNode.SetMix(0);
    }
});

const echoResetBtn = CreateHTMLElement('btn', echoTop, 'echoResetBtn', true);
AttachTooltip(echoResetBtn, 'Reset', 100);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-reply');
    echoResetBtn.appendChild(i);
}
echoResetBtn.addEventListener('click', () => {
    Animate(echoResetBtn, 'rotate-left', 500);

    const intervalDelay = 10; //In ms

    const previousEchoDelay = echoDelay;
    const previousEchoFeedback = echoFeedback;
    const previousEchoMix = echoMix;

    const dimValue = intervalDelay / 500;
    let t = 0;
    const interval = setInterval(() => {
        echoDelay = previousEchoDelay + (defaultEchoDelay - previousEchoDelay) * t;
        echoFeedback = previousEchoFeedback + (defaultEchoFeedback - previousEchoFeedback) * t;
        echoMix = previousEchoMix + (defaultEchoMix - previousEchoMix) * t;

        UpdateEchoTexts(3);
        for (let i = 0; i < 3; i++) DisplayEchoSliders(i);

        if (t > 1) clearInterval(interval);
        t += dimValue;
    }, intervalDelay);

    echoNode.SetDelay(defaultEchoDelay);
    echoNode.SetMix(defaultEchoMix);
    echoNode.SetFeedback(defaultEchoFeedback);

    localStorage.setItem('echo', `${defaultEchoDelay};${defaultEchoFeedback};${defaultEchoMix}`);
});

const echoDelayBox = CreateHTMLElement('div', echoSliders, 'echoDelayBox', true);
const echoMixBox = CreateHTMLElement('div', echoSliders, 'echoMixBox', true);
const echoFeedbackBox = CreateHTMLElement('div', echoSliders, 'echoFeedbackBox', true);

function DisplayEchoSliders(slider) {
    let echoBox, id;
    if (slider == 0) {
        echoBox = echoDelayBox;
        id = 'echoDelaySVG';
    } else if (slider == 1) {
        echoBox = echoMixBox;
        id = 'echoMixSVG';
    } else if (slider == 2) {
        echoBox = echoFeedbackBox;
        id = 'echoFeedbackSVG';
    }

    const width = echoBox.clientWidth;
    const height = echoBox.clientHeight * 0.75;

    const echoSVG = document.createElementNS(svgNS, "svg");
    echoSVG.id = id;
    echoSVG.setAttribute("viewBox", `0 0 ${width} ${height}`);
    echoSVG.setAttribute("width", "100%");
    echoSVG.setAttribute("height", "75%");
    echoBox.appendChild(echoSVG);
    echoSVG.style.display = 'block';

    const arcPath = CreateEchoPath(width, height);

    const sliderPath = document.createElementNS(svgNS, "path");
    sliderPath.setAttribute('d', arcPath);
    sliderPath.setAttribute('stroke', '#888');
    sliderPath.setAttribute('stroke-width', '4');
    sliderPath.setAttribute('fill', 'none');

    echoSVG.appendChild(sliderPath);

    DisplayEchoSliders2(echoSVG, echoBox, slider);

    const children = Array.from(echoBox.children);
    for (const child of children) {
        if (child.namespaceURI === svgNS) {
            echoBox.removeChild(child);
        }
    }
    echoBox.appendChild(echoSVG);
}
function DisplayEchoSliders2(echoSVG, echoBox, slider) {
    let setting;
    if (slider == 0) {
        setting = echoDelay;
    } else if (slider == 1) {
        setting = echoMix;
    } else if (slider == 2) {
        setting = echoFeedback / 0.95;
    }

    const width = echoBox.clientWidth;
    const height = echoBox.clientHeight * 0.75;

    const size = Math.min(width, height) * 0.8;
    const radius = size / 2;

    const activeArc = document.createElementNS(svgNS, "path");
    const activePath = CreateEchoPath(width, height, setting);
    activeArc.setAttribute('d', activePath);
    activeArc.setAttribute('stroke', '#383');
    activeArc.setAttribute('stroke-width', '6');
    activeArc.setAttribute('fill', 'none');

    const handle = document.createElementNS(svgNS, 'circle');
    handle.setAttribute('cx', width / 2 + radius * Math.cos(setting * 0.75 * 2 * Math.PI + Math.PI));
    handle.setAttribute('cy', height / 2 + radius * Math.sin(setting * 0.75 * 2 * Math.PI + Math.PI));
    handle.setAttribute('r', '8');
    handle.setAttribute('fill', '#0f0');
    handle.setAttribute('stroke', '#fff');
    handle.setAttribute('stroke-width', '2');

    if (echoDragging.state && echoDragging.slider == slider) handle.style.cursor = 'grabbing';

    let isEchoMouseleaveAttached = false;
    handle.addEventListener('mousedown', () => {
        if (effectsContainer.style.display != 'none' && currentPage == 6) {
            echoDragging = {
                state: true,
                slider: slider
            };

            echoSVG.style.cursor = 'grabbing';
            handle.style.cursor = 'grabbing';

            if (!isEchoMouseleaveAttached) {
                isEchoMouseleaveAttached = true;

                echoSVG.addEventListener('mouseleave', () => {
                    if (!echoDragging.state) return;
                    else if (echoDragging.slider != slider) return;

                    echoDragging.state = false;
                    echoSVG.style.cursor = 'auto';

                    document.querySelectorAll('#echoSliders circle').forEach((knob) => { knob.style.cursor = 'grab'; });
                });
            }
        }
    });

    echoSVG.appendChild(activeArc);
    echoSVG.appendChild(handle);
}

function CreateEchoPath(width, height, completion = 1, steps = 60) {
    const startX = width / 2;
    const startY = height / 2;

    const size = Math.min(width, height) * 0.8;
    const radius = size / 2;

    let d = `M ${startX} ${startY}`;

    for (let i = 0; i <= steps; i++) {
        const t = i / steps * 0.75;
        if (t / 0.75 > completion) break;
        const angle = t * 2 * Math.PI + Math.PI;

        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);

        d += (i ? ' L' : 'M') + ` ${startX + x} ${startY + y}`;
    }

    return d;
}

function EchoOnMouseUp() {
    if (!echoDragging.state) return;
    echoDragging.state = false;

    document.querySelector('#echoDelaySVG').style.cursor = 'auto';
    document.querySelector('#echoFeedbackSVG').style.cursor = 'auto';
    document.querySelector('#echoMixSVG').style.cursor = 'auto';

    document.querySelectorAll('#echoSliders circle').forEach((knob) => { knob.style.cursor = 'grab'; });
}


let echoDragging = { state: false, slider: 0 };
function EchoOnMouseMove(e) {
    if (effectsContainer.style.display == 'none' || currentPage != 6 || !echoDragging.state) return;

    let echoSVG, echoBox;
    if (echoDragging.slider == 0) {
        echoSVG = document.querySelector('#echoDelaySVG');
        echoBox = echoDelayBox;
    } else if (echoDragging.slider == 1) {
        echoSVG = document.querySelector('#echoMixSVG');
        echoBox = echoMixBox;
    } else if (echoDragging.slider == 2) {
        echoSVG = document.querySelector('#echoFeedbackSVG');
        echoBox = echoFeedbackBox;
    }

    const width = echoSVG.clientWidth;
    const height = echoSVG.clientHeight;

    const startX = width / 2;
    const startY = height / 2;

    const rect = echoSVG.getBoundingClientRect();
    const cx = rect.left + startX;
    const cy = rect.top + startY;

    const dx = e.clientX - cx;
    const dy = e.clientY - cy;

    const angleRad = Math.atan2(dy, dx);
    let adjusted = (angleRad + Math.PI) % (2 * Math.PI); //Because the beginning of the circle is at  and not 0 and after that I clamp between 0 and 2
    adjusted /= 0.75; //Because I go from 0 to 2 in 75% of a circle so I have to adjust
    if (adjusted > 2 * Math.PI * (7 / 6)) adjusted = 0; //It's hard to explain but it's in order to put the value at 0 when you're between the end and the start point in the blank space

    let value = adjusted / 2 / Math.PI; //Finally I want a value between 0 and 1 so I divide by 2

    if (echoDragging.slider == 0) {
        value = Math.min(Math.max(0, value), 1);
        echoDelay = value;

        echoNode.SetDelay(echoDelay);

        const values = localStorage.getItem('echo').split(';');
        const str = echoDelay + ';' + values[1] + ';' + values[2];
        localStorage.setItem('echo', str.toString());
    } else if (echoDragging.slider == 1) {
        value = Math.min(Math.max(0, value), 1);
        echoMix = value;

        echoNode.SetMix(echoMix);

        const values = localStorage.getItem('echo').split(';');
        const str = values[0] + ';' + values[1] + ';' + echoMix;
        localStorage.setItem('echo', str.toString());
    } else if (echoDragging.slider == 2) {
        value = Math.min(Math.max(0, value), 0.95);
        echoFeedback = value;

        echoNode.SetFeedback(echoFeedback);

        const values = localStorage.getItem('echo').split(';');
        const str = values[0] + ';' + echoFeedback + ';' + values[2];
        localStorage.setItem('echo', str.toString());
    }

    UpdateEchoTexts(echoDragging.slider);
    for (let _ = 0; _ < 2; _++) echoSVG.removeChild(echoSVG.lastChild);
    DisplayEchoSliders2(echoSVG, echoBox, echoDragging.slider);
}

const echoDelayText = CreateHTMLElement('div', echoDelayBox, 'echoDelayText', true);
const echoMixText = CreateHTMLElement('div', echoMixBox, 'echoMixText', true);
const echoFeedbackText = CreateHTMLElement('div', echoFeedbackBox, 'echoFeedbackText', true);

const echoDelayTitle = CreateHTMLElement('div', echoDelayText, 'echoDelayTitle', true);
const echoMixTitle = CreateHTMLElement('div', echoMixText, 'echoMixTitle', true);
const echoFeedbackTitle = CreateHTMLElement('div', echoFeedbackText, 'echoFeedbackTitle', true);
{
    echoDelayTitle.textContent = 'Delay';
    echoMixTitle.textContent = 'Mix';
    echoFeedbackTitle.textContent = 'Feedback';
}

const echoDelayValue = CreateHTMLElement('div', echoDelayText, 'echoDelayValue', true);
const echoMixValue = CreateHTMLElement('div', echoMixText, 'echoMixValue', true);
const echoFeedbackValue = CreateHTMLElement('div', echoFeedbackText, 'echoFeedbackValue', true);
function UpdateEchoTexts(slider) {
    const all = slider == 3 ? true : false;
    if (slider == 0 || all) {
        const value = Math.round(echoDelay * 100) / 100;
        const length = value.toString().length;
        echoDelayValue.textContent = (length == 3 ? value + '0' : length == 1 ? value + '.00' : value) + ' s';
    }
    if (slider == 1 || all) {
        const value = Math.round(echoMix * 100);
        const length = value.toString().length;
        echoMixValue.textContent = value + ' %';
    }
    if (slider == 2 || all) {
        const value = Math.round(echoFeedback * 100) / 100;
        const length = value.toString().length;
        echoFeedbackValue.textContent = (length == 3 ? value + '0' : length == 1 ? value + '.00' : value) + ' s';
    }
}
UpdateEchoTexts(3);


document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 6) return;

    const key = event.code;
    if (key == 'Enter' || key == 'Space') {
        echoActivateBtn.click();
    }
});


// _____________________________________________ Distortion _______________________________________


const defaultDistortionBandWidth = 0.4;
const defaultDistortionLowPass = 0.6;
const defaultDistortionMix = 0.5;
if (!localStorage.getItem('distortion')) localStorage.setItem('distortion', `${defaultDistortionBandWidth};${defaultDistortionLowPass};${defaultDistortionMix}`);

const distortionValues = localStorage.getItem('distortion').split(';');
let distortionBandWidth = parseFloat(distortionValues[0]);
let distortionLowPass = parseFloat(distortionValues[1]);
let distortionMix = parseFloat(distortionValues[2]);

const distortionDryGain = audioCtx.createGain();
const distortionWetGain = audioCtx.createGain();

const distortionOffsetGain = audioCtx.createGain();
distortionOffsetGain.gain.value = 0.15; //Subjective value to attenuate the sound of distortion as it is naturally high

const distortionShaper = audioCtx.createWaveShaper(); // <-- the heart of distortion
const distortionFilter = audioCtx.createBiquadFilter();
distortionFilter.type = "lowpass";

const distortionOutput = audioCtx.createGain();
const distortionSendGain = audioCtx.createGain();

distortionDryGain.connect(distortionOutput);
distortionWetGain
    .connect(distortionShaper)
    .connect(distortionFilter)
    .connect(distortionOffsetGain)
    .connect(distortionOutput);

const distortionInput = audioCtx.createGain();
distortionInput.connect(distortionDryGain);
distortionInput.connect(distortionSendGain).connect(distortionWetGain);

//Generate the distortion curve
function makeDistortionCurve(amount = 50) {
    const samples = targetSampleRate;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        curve[i] = (3 + amount) * x * 20 * deg / (Math.PI + amount * Math.abs(x));
    }
    return curve;
}

const distortionNode = {
    input: distortionInput,
    output: distortionOutput,
    SetMix(mix) {
        distortionDryGain.gain.value = 1 - mix;
        distortionWetGain.gain.value = mix;
    },
    SetBandWidth(val) {
        const intensity = 100 + val * 4900;
        distortionShaper.curve = makeDistortionCurve(intensity);
        distortionShaper.oversample = '4x';
    },
    SetHighFreq(val) {
        distortionFilter.frequency.value = 1000 + val * 9000;
    }
};

distortionNode.SetMix(0); //By default it's deactivated
distortionNode.SetBandWidth(distortionBandWidth);
distortionNode.SetHighFreq(distortionLowPass);
distortionNode.output.connect(echoNode.input);


const distortionContent = CreateHTMLElement('div', document.querySelector('#distortionScreen'), 'distortionContent', true);

const distortionTop = CreateHTMLElement('div', distortionContent, 'distortionTop', true);
const distortionSliders = CreateHTMLElement('div', distortionContent, 'distortionSliders', true);

const distortionTitle = document.querySelector('#distortionScreen').firstChild;
document.querySelector('#distortionScreen').removeChild(distortionTitle);
distortionTop.appendChild(distortionTitle);

const distortionActivateBtn = CreateHTMLElement('btn', distortionTop, 'distortionActivateBtn', true);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-power-off');
    distortionActivateBtn.appendChild(i);
}
const distortionMask = CreateHTMLElement('div', distortionContent, 'distortionMask', true);
ChangeDisplay([distortionMask], 1); //By default it's deactivated
distortionActivateBtn.addEventListener('click', () => {
    if (distortionMask.style.display === 'flex') {
        ChangeDisplay([distortionMask], 0);

        distortionNode.SetMix(distortionMix);
    } else {
        ChangeDisplay([distortionMask], 1);

        distortionNode.SetMix(0);
    }
});

const distortionResetBtn = CreateHTMLElement('btn', distortionTop, 'distortionResetBtn', true);
AttachTooltip(distortionResetBtn, 'Reset', 100);
{
    const i = document.createElement('i');
    i.classList.add('fas');
    i.classList.add('fa-reply');
    distortionResetBtn.appendChild(i);
}
distortionResetBtn.addEventListener('click', () => {
    Animate(distortionResetBtn, 'rotate-left', 500);

    const intervalDelay = 10; //In ms

    const previousDistortionMix = distortionMix;
    const previousDistortionBandWidth = distortionBandWidth;
    const previousDistortionLowPass = distortionLowPass;

    const dimValue = intervalDelay / 500;
    let t = 0;
    const interval = setInterval(() => {
        distortionMix = previousDistortionMix + (defaultDistortionMix - previousDistortionMix) * t;
        distortionBandWidth = previousDistortionBandWidth + (defaultDistortionBandWidth - previousDistortionBandWidth) * t;
        distortionLowPass = previousDistortionLowPass + (defaultDistortionLowPass - previousDistortionLowPass) * t;

        UpdateDistortionTexts();
        for (let i = 0; i < 3; i++) DisplayDistortionSlider(i);

        if (t > 1) clearInterval(interval);
        t += dimValue;
    }, intervalDelay);

    distortionNode.SetMix(defaultDistortionMix);
    distortionNode.SetBandWidth(defaultDistortionBandWidth);
    distortionNode.SetHighFreq(defaultDistortionLowPass);

    localStorage.setItem('distortion', `${defaultDistortionBandWidth};${defaultDistortionLowPass};${defaultDistortionMix}`);
});

const distortionMixBox = CreateHTMLElement('div', distortionSliders, 'distortionMixBox', true);
const distortionBandWidthBox = CreateHTMLElement('div', distortionSliders, 'distortionBandWidthBox', true);
const distortionLowPassBox = CreateHTMLElement('div', distortionSliders, 'distortionLowPassBox', true);

const distortionMixSliderBox = CreateHTMLElement('div', distortionMixBox, 'distortionMixSliderBox', true);
const distortionBandWidthSliderBox = CreateHTMLElement('div', distortionBandWidthBox, 'distortionBandWidthSliderBox', true);
const distortionLowPassSliderBox = CreateHTMLElement('div', distortionLowPassBox, 'distortionLowPassSliderBox', true);


function DisplayDistortionSlider(index) {
    let distortionBox, id;
    if (index == 0) {
        distortionBox = distortionMixSliderBox;
        id = 'distortionMixSVG';
    } else if (index == 1) {
        distortionBox = distortionBandWidthSliderBox;
        id = 'distortionBandWidthSVG';
    } else if (index == 2) {
        distortionBox = distortionLowPassSliderBox;
        id = 'distortionLowPassSVG';
    }

    const width = distortionBox.clientWidth;
    const height = distortionBox.clientHeight;

    const distortionSVG = document.createElementNS(svgNS, "svg");
    distortionSVG.id = id;
    distortionSVG.setAttribute("viewBox", `0 0 ${width} ${height}`);
    distortionSVG.setAttribute("width", "100%");
    distortionSVG.setAttribute("height", "100%");
    distortionBox.appendChild(distortionSVG);
    distortionSVG.style.display = 'block';

    const arcPath = CreateDistortionPath(width, height);

    const sliderPath = document.createElementNS(svgNS, "path");
    sliderPath.setAttribute('d', arcPath);
    sliderPath.setAttribute('stroke', '#888');
    sliderPath.setAttribute('stroke-width', '4');
    sliderPath.setAttribute('fill', 'none');

    distortionSVG.appendChild(sliderPath);

    DisplayDistortionSlider2(distortionSVG, distortionBox, index);

    const children = Array.from(distortionBox.children);
    for (const child of children) {
        if (child.namespaceURI === svgNS) {
            distortionBox.removeChild(child);
        }
    }
    distortionBox.appendChild(distortionSVG);
}
function CreateDistortionPath(width, height, completion = 1, steps = 60) {
    const startX = width / 2;
    const usableWidth = width * 0.04;
    const usableHeight = height * 0.8;
    const startY = height * 0.9;
    const amplitude = usableWidth / 2;

    let d = `M ${startX} ${startY}`;

    for (let i = 0; i <= steps; i++) {
        const t = i / steps; //0  1
        if (t > completion) break;
        const angle = t * 2 * Math.PI * 3; //0  6 (for the beauty)
        const x = startX + Math.sin(angle) * amplitude;
        const y = startY - usableHeight * t;

        d += ` L ${x} ${y}`;
    }

    return d;
}
function DisplayDistortionSlider2(distortionSVG, distortionBox, index) {
    let value;
    if (index == 0) {
        value = distortionMix;
    } else if (index == 1) {
        value = distortionBandWidth;
    } else if (index == 2) {
        value = distortionLowPass;
    }

    const width = distortionBox.clientWidth;
    const height = distortionBox.clientHeight;

    const activeArc = document.createElementNS(svgNS, "path");
    const activePath = CreateDistortionPath(width, height, value);
    activeArc.setAttribute('d', activePath);
    activeArc.setAttribute('stroke', `rgba(255, ${96 + (192 - 96) * (1 - value)}, ${96 + (192 - 96) * (1 - value)}, 1)`);
    activeArc.setAttribute('stroke-width', '6');
    activeArc.setAttribute('fill', 'none');

    const endX = width / 2 + Math.sin(value * 2 * Math.PI * 3) * width * 0.02;
    const endY = height * 0.9 - height * 0.8 * value;

    const handle = document.createElementNS(svgNS, 'circle');
    handle.setAttribute('cx', endX);
    handle.setAttribute('cy', endY);
    handle.setAttribute('r', '8');
    handle.setAttribute('fill', 'rgba(255, 96, 96, 1)');
    handle.setAttribute('stroke', '#fff');
    handle.setAttribute('stroke-width', '2');

    if (distortionDragging.state && index == distortionDragging.index) handle.style.cursor = 'grabbing';

    let isDistortionMouseleaveAttached = false;
    handle.addEventListener('mousedown', () => {
        if (effectsContainer.style.display !== 'none' && currentPage === 7) {
            distortionDragging = {
                state: true,
                index: index
            };

            distortionSVG.style.cursor = 'grabbing';
            handle.style.cursor = 'grabbing';

            if (!isDistortionMouseleaveAttached) {
                isDistortionMouseleaveAttached = true;

                distortionSVG.addEventListener('mouseleave', () => {
                    if (!distortionDragging.state) return;
                    else if (distortionDragging.index !== index) return;

                    distortionDragging.state = false;
                    distortionSVG.style.cursor = 'auto';
                    handle.style.cursor = 'grab';
                });
            }
        }
    });

    distortionSVG.appendChild(activeArc);
    distortionSVG.appendChild(handle);
}

let distortionDragging = { state: false, index: 0 };
function DistortionOnMouseMove(e) {
    if (effectsContainer.style.display == 'none' || currentPage != 7 || !distortionDragging.state) return;

    let distortionSVG, distortionBox;
    if (distortionDragging.index == 0) {
        distortionSVG = document.querySelector('#distortionMixSVG');
        distortionBox = distortionMixSliderBox;
    } else if (distortionDragging.index == 1) {
        distortionSVG = document.querySelector('#distortionBandWidthSVG');
        distortionBox = distortionBandWidthSliderBox;
    } else if (distortionDragging.index == 2) {
        distortionSVG = document.querySelector('#distortionLowPassSVG');
        distortionBox = distortionLowPassSliderBox;
    }

    const height = distortionBox.clientHeight;

    const cy = distortionBox.getBoundingClientRect().top + height * 0.9;

    const dy = cy - e.clientY;

    let value = Math.min(Math.max(0, dy / (height * 0.8)), 1); //Value between 0 and 1

    if (distortionDragging.index == 0) {
        distortionMix = parseFloat(value);

        distortionNode.SetMix(distortionMix);

        UpdateDistortionTexts(0);

        const values = localStorage.getItem('distortion').split(';');
        localStorage.setItem('distortion', `${values[0]};${values[1]};${distortionMix}`);
    } else if (distortionDragging.index == 1) {
        distortionBandWidth = parseFloat(value);

        distortionNode.SetBandWidth(distortionBandWidth);

        UpdateDistortionTexts(1);

        const values = localStorage.getItem('distortion').split(';');
        localStorage.setItem('distortion', `${distortionBandWidth};${values[1]};${values[2]}`);
    } else if (distortionDragging.index == 2) {
        distortionLowPass = parseFloat(value);

        distortionNode.SetHighFreq(distortionLowPass);

        UpdateDistortionTexts(2);

        const values = localStorage.getItem('distortion').split(';');
        localStorage.setItem('distortion', `${values[0]};${distortionLowPass};${values[2]}`);
    }

    for (let _ = 0; _ < 2; _++) distortionSVG.removeChild(distortionSVG.lastChild);
    DisplayDistortionSlider2(distortionSVG, distortionBox, distortionDragging.index);
}

function DistortionOnMouseUp() {
    if (!distortionDragging.state) return;
    distortionDragging.state = false;

    document.querySelector('#distortionMixSVG').style.cursor = 'auto';
    document.querySelector('#distortionBandWidthSVG').style.cursor = 'auto';
    document.querySelector('#distortionLowPassSVG').style.cursor = 'auto';

    document.querySelector('#distortionMixSVG circle').style.cursor = 'grab';
    document.querySelector('#distortionBandWidthSVG circle').style.cursor = 'grab';
    document.querySelector('#distortionLowPassSVG circle').style.cursor = 'grab';
}


const distortionMixText = CreateHTMLElement('div', distortionMixBox, 'distortionMixText', true);
const distortionBandWidthText = CreateHTMLElement('div', distortionBandWidthBox, 'distortionBandWidthText', true);
const distortionLowPassText = CreateHTMLElement('div', distortionLowPassBox, 'distortionLowPassText', true);

const distortionMixTitle = CreateHTMLElement('div', distortionMixText, 'distortionMixTitle', true);
const distortionBandWidthTitle = CreateHTMLElement('div', distortionBandWidthText, 'distortionBandWidthTitle', true);
const distortionLowPassTitle = CreateHTMLElement('div', distortionLowPassText, 'distortionLowPassTitle', true);
distortionMixTitle.textContent = 'Mix';
distortionBandWidthTitle.textContent = 'Band Width';
distortionLowPassTitle.textContent = 'Low Pass';

const distortionMixValue = CreateHTMLElement('div', distortionMixText, 'distortionMixValue', true);
const distortionBandWidthValue = CreateHTMLElement('div', distortionBandWidthText, 'distortionBandWidthValue', true);
const distortionLowPassValue = CreateHTMLElement('div', distortionLowPassText, 'distortionLowPassValue', true);

const distortionMixTrueValue = CreateHTMLElement('div', distortionMixText, 'distortionMixTrueValue', true);
const distortionBandWidthTrueValue = CreateHTMLElement('div', distortionBandWidthText, 'distortionBandWidthTrueValue', true);
const distortionLowPassTrueValue = CreateHTMLElement('div', distortionLowPassText, 'distortionLowPassTrueValue', true);

function UpdateDistortionTexts(slider = 3) {
    const all = slider == 3 ? true : false;
    if (slider == 0 || all) {
        const value = Math.round(distortionMix * 100) / 100;
        const length = value.toString().length;
        distortionMixValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

        const trueValue = Math.round(distortionMix * 100);
        distortionMixTrueValue.textContent = trueValue + ' %';
    }
    if (slider == 1 || all) {
        const value = Math.round(distortionBandWidth * 100) / 100;
        const length = value.toString().length;
        distortionBandWidthValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

        const trueValue = Math.round(100 + distortionBandWidth * 4900);
        distortionBandWidthTrueValue.textContent = trueValue + ' Hz';
    }
    if (slider == 2 || all) {
        const value = Math.round(distortionLowPass * 100) / 100;
        const length = value.toString().length;
        distortionLowPassValue.textContent = length == 3 ? value + '0' : length == 1 ? value + '.00' : value;

        const trueValue = Math.round(1000 + distortionLowPass * 9000);
        distortionLowPassTrueValue.textContent = trueValue + ' Hz';
    }
}
UpdateDistortionTexts();


document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 7) return;

    const key = event.code;
    if (key == 'Enter' || key == 'Space') {
        distortionActivateBtn.click();
    }
});


// _____________________________________________ Metronome ________________________________________


const defaultMetronomeValue = 60;
if (!localStorage.getItem('metronome')) localStorage.setItem('metronome', defaultMetronomeValue.toString());
let metronomeBPM = localStorage.getItem('metronome');
let metronomeMode = false; //By default it's deactivated

const metronomeContent = CreateHTMLElement('div', document.querySelector('#metronomeScreen'), 'metronomeContent', true);

const metronomeBtn = CreateHTMLElement('btn', metronomeContent, 'metronomeBtn', true);
const metronomeIcon = CreateHTMLElement('img', metronomeBtn, 'metronomeIcon', true);
metronomeIcon.src = "Pictures/metronomeIconBlack.png";
metronomeBtn.addEventListener('mouseover', () => { setTimeout(() => { metronomeIcon.src = "Pictures/metronomeIconWhite.png"; }, 250); });
metronomeBtn.addEventListener('mouseleave', () => { setTimeout(() => { metronomeIcon.src = "Pictures/metronomeIconBlack.png"; }, 250); });

const metronomeSliderBox = CreateHTMLElement('div', metronomeContent, 'metronomeSliderBox', true);

const metronomeSlider = CreateInput('metronomeSlider', '20', '208', defaultMetronomeValue, 'range', metronomeSliderBox);

metronomeSlider.addEventListener('mouseup', () => {
    metronomeSlider.blur();
});
metronomeSlider.addEventListener('touchend', () => {
    metronomeSlider.blur();
});

metronomeSlider.value = metronomeBPM;
metronomeSlider.addEventListener('input', () => {
    metronomeBPM = metronomeSlider.value;

    metronomeText.textContent = `${metronomeBPM} bpm`;
    metronomeTempo.textContent = ReturnTempo(metronomeBPM);

    localStorage.setItem('metronome', metronomeBPM.toString());

    if (metronomeMode) {
        clearInterval(metronomeInterval);
        metronomeInterval = setInterval(() => {
            metronomeNote.play();
        }, 60000 / metronomeBPM);
    }
});

const metronomeText = CreateHTMLElement('div', metronomeSliderBox, 'metronomeText', true);
metronomeText.textContent = `${metronomeBPM} bpm`;

const metronomeTempo = CreateHTMLElement('div', metronomeSliderBox, 'metronomeTempo', true);
metronomeTempo.textContent = ReturnTempo(metronomeBPM);

function ReturnTempo(bpm) {
    if (bpm < 40) return "Grave";
    if (bpm < 60) return "Largo / Larghetto";
    if (bpm < 80) return "Lento / Adagio";
    if (bpm < 108) return "Andante / Andantino";
    if (bpm < 120) return "Moderato";
    if (bpm < 168) return "Allegro";
    if (bpm < 200) return "Presto";
    if (bpm < 208) return "Prestissimo";
    return "Extrem"
}

let metronomeNote;
async function CreateMetronomeAudioVoice() {
    const gainNode = audioCtx.createGain();

    if (metronomeSound.startsWith("data:")) {
        metronomeSound = metronomeSound.split(",")[1];
    }
    const binary = atob(metronomeSound);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    let blob = new Blob([bytes], { type: "audio/mp3" });

    const arrayBuffer = await blob.arrayBuffer();
    const buffer = await audioCtx.decodeAudioData(arrayBuffer);

    const sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = buffer;

    metronomeNote = {
        gainNode,
        currentSourceNode: null,
        play: function () {
            if (this.currentSourceNode) {
                try { this.currentSourceNode.stop(); } catch { }
            }

            clearTimeout(this.releaseTimeout);

            const now = audioCtx.currentTime;
            const gain = this.gainNode.gain;

            gain.cancelScheduledValues(now);

            const vol = this.volume ?? 1;
            gain.setValueAtTime(vol, now);

            this.gainNode.gain.value = volumeValue / 100;

            const sourceNode = audioCtx.createBufferSource();
            sourceNode.buffer = buffer;
            sourceNode.connect(this.gainNode).connect(audioCtx.destination);
            sourceNode.start(0);

            this.currentSourceNode = sourceNode;
        }
    }
}
requestAnimationFrame(CreateMetronomeAudioVoice);

let metronomeInterval = null;
function ToggleMetronomeMode() {
    metronomeMode = !metronomeMode;

    if (metronomeMode) {
        metronomeInterval = setInterval(() => {
            metronomeNote.play();
        }, 60000 / metronomeBPM);
    } else {
        clearInterval(metronomeInterval);
        metronomeInterval = null;
    }
}

const metronomeSVG = document.createElementNS(svgNS, "svg");
metronomeSVG.id = 'metronomeSVG';
metronomeSVG.setAttribute("viewBox", "0 0 200 200");
metronomeSVG.setAttribute("width", "100%");
metronomeSVG.setAttribute("height", "100%");
metronomeContent.appendChild(metronomeSVG);

for (let i = 0; i < numberOfCirclesForMetronome; i++) {
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', '100');
    circle.setAttribute('cy', '100');
    circle.setAttribute('r', '0');
    circle.setAttribute('stroke-width', '3');
    circle.setAttribute('fill', 'none');

    metronomeSVG.appendChild(circle);
}


let animationStartTimeForMetronome = null;
function AnimateWaveForMetronome() {
    if (animationStartTimeForMetronome != null && performance.now() - animationStartTimeForMetronome < 1000) return;

    ToggleMetronomeMode();

    let r = 0;
    const maxR = 300;
    const duration = 1000;
    animationStartTimeForMetronome = performance.now();

    function Step(now) {
        let progress = 0;
        for (let i = 0; i < numberOfCirclesForMetronome; i++) {
            const circle = metronomeSVG.children[i];
            const elapsed = now - animationStartTimeForMetronome - i * 100;
            progress = Math.max(0, Math.min(elapsed / duration, 1));

            r = maxR * progress;
            circle.setAttribute('r', r);
            circle.style.strokeOpacity = 1 - progress;

            if (progress < .03) {
                if (metronomeMode) circle.setAttribute('stroke', 'rgba(0, 255, 0, 0.7)');
                else circle.setAttribute('stroke', 'rgba(255, 0, 0, 0.7)');
            }

            if (!i) {
                const start = metronomeMode ? colors[1] : colors[0];
                const end = metronomeMode ? colors[0] : colors[1];

                const red = start[0] + progress * (end[0] - start[0]);
                const green = start[1] + progress * (end[1] - start[1]);
                const blue = start[2] + progress * (end[2] - start[2]);

                document.querySelector('#metronomeScreen').style.background = `rgba(${red}, ${green}, ${blue}, 1)`;
            }
        }

        if (progress < 1) {
            requestAnimationFrame(Step);
        } else {
            for (let i = 0; i < numberOfCirclesForMetronome; i++) {
                const circle = metronomeSVG.children[i];
                circle.setAttribute('r', 0);
                circle.style.strokeOpacity = 0;
            }
        }
    }

    requestAnimationFrame(Step);
}

metronomeBtn.addEventListener('click', AnimateWaveForMetronome);

document.addEventListener('keydown', (event) => {
    if (effectsContainer.style.display == 'none' || currentPage != 8) return;

    const key = event.code;
    if (key == 'Enter' || key == 'Space') {
        AnimateWaveForMetronome();
    }
});


// _____________________________________________ Update ___________________________________________


window.addEventListener('resize', UpdatePosition);
function UpdatePosition() {
    if (currentPage == 0) {
        UpdateKnobFromVolume();
        CalculatePositions();
    } else if (currentPage == 1) {
        panoramicSettings.style.width = `${panoramicContent.clientWidth - panoramicView.clientWidth}vw`;
    } else if (currentPage == 2) {
        const col = colors[sustainMode ? 0 : 1];
        document.querySelector('#sustainScreen').style.background = `rgba(${col[0]}, ${col[1]}, ${col[2]}, 1)`;
    } else if (currentPage == 3) {
        DisplayReverbSlider(true);
        DisplayReverbSlider(false);
        PlaceCloseButtonForReverbName(1000);
    } else if (currentPage == 4) {
        for (let i = 0; i < 4; i++) DisplayChorusSlider(i); //I'm redrawing the sliders each time the window is being resized. I know it's overkilled and it would probably work without but I made it like that and it works. Now changing everything would cost me more than letting a method that already does its job real fine so I'm letting it...
    } else if (currentPage == 5) {
        DisplayADSR();
    } else if (currentPage == 6) {
        for (let i = 0; i < 3;  i++) DisplayEchoSliders(i);
    } else if (currentPage == 7) {
        for (let i = 0; i < 3; i++) DisplayDistortionSlider(i);
    } else if (currentPage == 8) {
        const col = colors[metronomeMode ? 0 : 1];
        document.querySelector('#metronomeScreen').style.background = `rgba(${col[0]}, ${col[1]}, ${col[2]}, 1)`;
    }

    if (currentPage != 0) {
        cancelAnimationFrame(waveAnimationId);
        waveAnimationId = null;
    }
}

function UpdateEventListeners(previousWindow, nextWindow) {
    // ________________________________ Remove Event Listeners ____________________________

    if (previousWindow == 0) {
        volumeKnob.removeEventListener('mousedown', VolumeOnMouseDown);
        window.removeEventListener('mouseup', VolumeOnMouseUp);
        window.removeEventListener('mousemove', VolumeOnMouseMove);
    } else if (previousWindow == 1) {
        panoramicKnob.removeEventListener('mousedown', PanoramicOnMouseDown1);
        panoramicView.removeEventListener('mousedown', PanoramicOnMouseDown2);
        window.removeEventListener('mouseup', PanoramicOnMouseUp);
        window.removeEventListener('mousemove', PanoramicOnMouseMove);
    } else if (previousWindow == 2) {
        //Nothing to do here for sustain but I keep this if statement "in case of" you know .. ??
    } else if (previousWindow == 3) {
        window.removeEventListener('mouseup', ReverbOnMouseUp);
        window.removeEventListener('mousemove', ReverbOnMouseMove);
    } else if (previousWindow == 4) {
        window.removeEventListener('mouseup', ChorusOnMouseUp);
        window.removeEventListener('mousemove', ChorusOnMouseMove);
    } else if (previousWindow == 5) {
        window.removeEventListener('mouseup', AdsrOnMouseUp);
        window.removeEventListener('mousemove', AdsrOnMouseMove);
    } else if (previousWindow == 6) {
        window.removeEventListener('mouseup', EchoOnMouseUp);
        window.removeEventListener('mousemove', EchoOnMouseMove);
    } else if (previousWindow == 7) {
        window.removeEventListener('mouseup', DistortionOnMouseUp);
        window.removeEventListener('mousemove', DistortionOnMouseMove);
    } else if (previousWindow == 8) {
        //Nothing to do here for metronome but I keep this if statement "in case of" .. ??
    }


    // ________________________________ Add Event Listeners ____________________________

    if (nextWindow == 0) {
        volumeKnob.addEventListener('mousedown', VolumeOnMouseDown);
        window.addEventListener('mouseup', VolumeOnMouseUp);
        window.addEventListener('mousemove', VolumeOnMouseMove);
    } else if (nextWindow == 1) {
        panoramicKnob.addEventListener('mousedown', PanoramicOnMouseDown1);
        panoramicView.addEventListener('mousedown', PanoramicOnMouseDown2);
        window.addEventListener('mouseup', PanoramicOnMouseUp);
        window.addEventListener('mousemove', PanoramicOnMouseMove);
    } else if (nextWindow == 2) {
        //Nothing to do here for sustain but I keep this if statement "in case of" you know .. ??
    } else if (nextWindow == 3) {
        window.addEventListener('mouseup', ReverbOnMouseUp);
        window.addEventListener('mousemove', ReverbOnMouseMove);
    } else if (nextWindow == 4) {
        window.addEventListener('mouseup', ChorusOnMouseUp);
        window.addEventListener('mousemove', ChorusOnMouseMove);
    } else if (nextWindow == 5) {
        window.addEventListener('mouseup', AdsrOnMouseUp);
        window.addEventListener('mousemove', AdsrOnMouseMove);
    } else if (nextWindow == 6) {
        window.addEventListener('mouseup', EchoOnMouseUp);
        window.addEventListener('mousemove', EchoOnMouseMove);
    } else if (nextWindow == 7) {
        window.addEventListener('mouseup', DistortionOnMouseUp);
        window.addEventListener('mousemove', DistortionOnMouseMove);
    } else if (nextWindow == 8) {
        //Nothing to do here for metronome but I keep this if statement "in case of" .. ??
    }
}
